# 树



## 树的基本概念

树是数据元素之间具有次层关系的非线性的结构，树是由 n (n>=0) 个节点组成的有限集合。

![image-20201203181745404](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203181745404.png)

- **根节点**： 根节点是没有双亲的节点，一棵树中最多只有一个根节点
- **孩子节点：**一棵树中，该节点向下延伸的节点，比如A的孩子节点是BCD
- **父母节点：**一棵树中，该节点向上延伸的节点，比如BCD的父母节点是A
- **兄弟节点：**同为一个父母节点延伸出来的是兄弟节点，BCD是兄弟节点
- **祖先节点：**简而言之，父母节点的父母节点...都成为祖先节点，比如E的祖先节点是A
- **叶子节点：**没有孩子结点，如同树叶一样，没办法向下延伸
- **节点的度：**所有有子树的颗树。A的度为3



## 二叉树

### 二叉树的定义

> 定义：二叉树(Binary Tree) 由一个根节点和两颗互不相交的左右子树的子二叉树构成。每个节点最多只有两个分叉。

**特殊的二叉树**

- 满二叉树

  满二叉树的最大特点是每一层次的结点数都达到最大值

  <img src="C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203182922197.png" alt="image-20201203182922197" style="zoom:67%;" />

- 完全二叉树

  假设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

  ![image-20201203183014231](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203183014231.png)



### 二叉树首相数据类型

> 应该实现树应有的：
>
> - 插入
> - 删除
> - 查找
> - 是否包含
> - 等

```java
package src.Tree.BinaryTree;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-11-25 2:27
 * @Version : 1.0
 */
public interface Tree <T extends Comparable> {

    /**
     * 判断是否为空
     */
    boolean isEmpty();

    /**
     * 二叉树结点个数
     */
    int size();

    /**
     * 返回二叉树的高度或者深度，即结点的最大层次
     */
    int height();

    /**
     * 前序遍历
     *
     */
    String preOrder();

    /**
     * 中序遍历
     *
     */
    String inOrder();

    /**
     * 后序遍历
     */
    String postOrder();

    /**
     * 层次遍历
     */
    String levelOrder();

    /**
     * 将data插入
     */
    void insert(T data);

    /**
     * 删除
     */
    void remove(T data);

    /**
     * 查找最大值
     */
    T findMax();

    /**
     * 查找最小值
     */
    T findMin();

    /**
     * 根据值查找到结点
     */
    BinaryNode findNode(T data);

    /**
     * 是否包含某个值
     */
    boolean contains(T data);

    /**
     * 清空
     */
    void clear();
}
```

## 二叉查找树

### 背景

> 为什么不实现二叉树呢？
>
> 因为二叉树的插入是没有规则的，所以编写二叉树的接口并没有实际的意义，而且日常生活中并不常用普通二叉树作为数据结构。

### 定义

二叉查找树的特性是，对于树种的每个结点T（T可能是父结点）,它的左子树中所有项的值小T中的值，而它的右子树中所有项的值都大于T中的值。

### 二叉查找树代码

#### 二叉查找树节点定义

这意味着该树所有的元素可以用某种规则进行排序(取决于Comparable接口的实现)。二叉查找树使用二叉链表存储结构实现，其结点`BinaryNode＜T＞`声明如下：

```java
package src.Tree.BinaryTree;

import java.beans.BeanInfo;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-11-25 2:39
 * @Version : 1.0
 */
public class BinaryNode<T extends Comparable>{

    private static final long serialVersionUID = -6477238039299912313L;

    public BinaryNode<T> left;  //左节点

    public BinaryNode<T> right; //右节点

    public T data;

    public BinaryNode(T data, BinaryNode left, BinaryNode right){
        this.data = data;
        this.left = left;
        this.right = right;
    }

    public BinaryNode(T data){
        this(data, null, null);
    }

    /**
     * 判断是否为叶子节点
     */
    public boolean isLeaf(){
        return this.left == null && this.right == null;
    }

}

```

#### 二叉查找树类定义

二叉查找树继承与Tree接口，对Tree接口中的方法实现重写。

```java
package src.Tree.BinaryTree;


import java.beans.BeanInfo;
import java.net.StandardSocketOptions;
import java.util.EmptyStackException;
import java.util.LinkedList;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-11-25 2:44
 * @Version : 1.0
 */
public class BinarySearchTree<T extends Comparable> implements Tree<T> {
    //根结点
    protected BinaryNode<T> root;

    public BinarySearchTree(){
        root =null;
    }
    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public int size() {
        return 0;
    }

    @Override
    public int height() {
        return 0;
    }

    @Override
    public String preOrder() {
        return null;
    }

    @Override
    public String inOrder() {
        return null;
    }

    @Override
    public String postOrder() {
        return null;
    }

    @Override
    public String levelOrder() {
        return null;
    }

    @Override
    public void insert(T data) {

    }

    @Override
    public void remove(T data) {

    }

    @Override
    public T findMin() {
        return null;
    }

    @Override
    public T findMax() {
        return null;
    }

    @Override
    public BinaryNode findNode(T data) {
        return null;
    }

    @Override
    public boolean contains(T data) throws Exception {
        return false;
    }

    @Override
    public void clear() {

    }
}

```

加下来就是实现该类的全部代码了

**二叉查找树的插入**

> 如果节点的值比data大：则往节点的左子树前进
>
> 如果节点的值比data小：则往节点的右子树前进
>
> 如果节点的值比data一样：不做修改
>
> 如果此时节点为空，则插入

<img src="C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203190947786.png" alt="image-20201203190947786" style="zoom:67%;" />

代码如下：

```java
@Override
public void insert(T data) {
    if (data==null)
        throw new RuntimeException("data can\'Comparable be null !");
    //插入操作
    root=insert(data,root);
}

/**
 * 插入操作,递归实现
 * @param data
 * @param p
 * @return
 */
private BinaryNode<T> insert(T data,BinaryNode<T> p){
    if(p==null){
        p=new BinaryNode<>(data,null,null);
    }

    //比较插入结点的值，决定向左子树还是右子树搜索
    int compareResult=data.compareTo(p.data);

    if (compareResult<0){//左
        p.left=insert(data,p.left);
    }else if(compareResult>0){//右
        p.right=insert(data,p.right);
    }else {
        ;//已有元素就没必要重复插入了
    }
    return p;
}
```

**二叉树的删除**

> 多种情况：
>
> 1. 如果删除节点是叶子节点，则直接删除
> 2. 如果删除节点拥有一个孩子节点，则父节点指向删除节点的子节点
> 3. 如果要删除的结点q拥有两个孩子结点，则删除策略是用q的右子树的最小的数据替代要被删除结点的数据，并递归删除用于替换的结点(此时该结点已为空)，此时二叉查找树的结构并不会被打乱，其特性仍旧生效。（因为： 右子树的最小结点的数据替换要被删除的结点后可以满足维持二叉查找树的结构和特性，又因为右子树最小结点不可能有左孩子，删除起来也相对简单些。）

- 节点是叶子节点

  <img src="C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203191524080.png" alt="image-20201203191524080" style="zoom:50%;" />

- 具有一个孩子节点

  <img src="C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203191604936.png" alt="image-20201203191604936" style="zoom:50%;" />

- 拥有两个孩子节点删除

  ![image-20201203191651606](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203191651606.png)

递归代码如下：

```java
@Override
public void remove(T data) {
  if(data==null)
      throw new RuntimeException("data can\'Comparable be null !");
  //删除结点
  root=remove(data,root);
}

/**
* 分3种情况
* 1.删除叶子结点(也就是没有孩子结点)
* 2.删除拥有一个孩子结点的结点(可能是左孩子也可能是右孩子)
* 3.删除拥有两个孩子结点的结点
* @param data
* @param p
* @return
*/
private BinaryNode<T> remove(T data,BinaryNode<T> p){
  //没有找到要删除的元素,递归结束
  if (p==null){
      return p;
  }
  int compareResult=data.compareTo(p.data);
  if (compareResult<0){//左边查找删除结点
      p.left=remove(data,p.left);
  }else if (compareResult>0) {
      p.right=remove(data,p.right);
  }else if (p.left!=null&&p.right!=null){//已找到结点并判断是否有两个子结点(情况3)
      //中继替换，找到右子树中最小的元素并替换需要删除的元素值
      p.data = findMin( p.right ).data;
      //移除用于替换的结点
      p.right = remove( p.data, p.right );
  }else {
      //拥有一个孩子结点的结点和叶子结点的情况
      p=(p.left!=null)? p.left : p.right;
  }

  return p;//返回该结点
}
```

非递归删除

```java
/**
  * 非递归删除
  * @param data
  */
 public T removeUnrecure(T data){
     if (data==null){
         throw new RuntimeException("data can\'Comparable be null !");
     }
     //从根结点开始查找
     BinaryNode<T> current =this.root;
     //记录父结点
     BinaryNode<T> parent=this.root;
     //判断左右孩子的flag
     boolean isLeft=true;


     //找到要删除的结点
     while (data.compareTo(current.data)!=0){
         //更新父结点记录
         parent=current;
         int result=data.compareTo(current.data);

         if(result<0){//从左子树查找
             isLeft=true;
             current=current.left;
         }else if(result>0){//从右子树查找
             isLeft=false;
             current=current.right;
         }
         //如果没有找到,返回null
         if (current==null){
             return null;
         }
     }

     //----------到这里说明已找到要删除的结点

     //删除的是叶子结点
     if (current.left==null&&current.right==null){
         if (current==this.root){
             this.root=null;
         } else if(isLeft){
             parent.left=null;
         }else {
             parent.right=null;
         }
     }
     //删除带有一个孩子结点的结点,当current的right不为null
     else if (current.left==null){
         if (current==this.root){
             this.root=current.right;
         }else if(isLeft){//current为parent的左孩子
             parent.left=current.right;
         }else {//current为parent的右孩子
             parent.right=current.right;
         }
     }
     //删除带有一个孩子结点的结点,当current的left不为null
     else if(current.right==null){
         if (current==this.root){
             this.root=current.left;
         }else if (isLeft){//current为parent的左孩子
             parent.left=current.left;
         }else {//current为parent的右孩子
             parent.right=current.left;
         }
     }
     //删除带有两个孩子结点的结点
     else {
         //找到当前要删除结点current的右子树中的最小值元素
         BinaryNode<T> successor= findSuccessor(current);

         if(current == root) {
             this.root = successor;
         } else if(isLeft) {
             parent.left = successor;
         } else{
             parent.right = successor;
         }
         //把当前要删除的结点的左孩子赋值给successor
         successor.left = current.left;
     }
     return current.data;
 }

 /**
  * 查找中继结点--右子树最小值结点
  * @param delNode 要删除的结点
  * @return
  */
 public BinaryNode<T> findSuccessor(BinaryNode<T> delNode) {
     BinaryNode<T> successor = delNode;
     BinaryNode<T> successorParent = delNode;
     BinaryNode<T> current = delNode.right;

     //不断查找左结点,直到为空,则successor为最小值结点
     while(current != null) {
         successorParent = successor;
         successor = current;
         current = current.left;
     }
     //如果要删除结点的右孩子与successor不相等,则执行如下操作(如果相当,则说明删除结点)
     if(successor != delNode.right) {
         successorParent.left = successor.right;
         //把中继结点的右孩子指向当前要删除结点的右孩子
         successor.right = delNode.right;
     }
     return successor;
 }
```

**查找最大和最小值**

- 对于findMin()，则需要从根结点开始并且只要有左孩子就向左进行即可，其终止点即为最小值的元素；

- 对于findMax()，也需要从根结点开始并且只要有右孩子就向右进行即可

```java
@Override
public T findMin() {
   if(isEmpty())
       throw new EmptyTreeException("BinarySearchTree is empty!");

   return findMin(root).data;
}

@Override
public T findMax() {
   if(isEmpty())
       throw new EmptyTreeException("BinarySearchTree is empty!");

   return findMax(root).data;
}

/**
* 查找最小值结点
* @param p
* @return
*/
private BinaryNode<T> findMin(BinaryNode<T> p){

   if (p==null)//结束条件
       return null;
   else if (p.left==null)//如果没有左结点,那么t就是最小的
       return p;
   return findMin(p.left);
}

/**
* 查找最大值结点
* @param p
* @return
*/
private BinaryNode<T> findMax(BinaryNode<T> p){
   if (p==null)//结束条件
       return null;
   else if (p.right==null)
       return p;
   return findMax(p.right);
}
```

**二叉树的深度**

然后计算出左子树的深度和右子树的深度，接着比较左子树与右子树的深度，最后返回深度大的即可。

![image-20201203192243385](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203192243385.png)

代码如下：

```java
/**
 * 计算深度
 * @return
 */
@Override
public int height() {
    return height(root);
}

/**
 * 递归实现
 * @param subtree
 * @return
 */
private int height(BinaryNode<T> subtree){
    if (subtree==null){
        return 0;
    }else {
        int l=height(subtree.left);
        int r=height(subtree.right);
        return (l>r) ? (l+1):(r+1);//返回并加上当前层
    }
}
```

**求二叉树大小**

一层一层找就行

![image-20201203192350270](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203192350270.png)

代码如下：

```java
/**
    * 计算大小
    * @return
    */
    @Override
    public int size() {
       return size(root);
    }

    /**
    * 递归实现：定义根节点root后，再用subtree实现递归
    * @param subtree
    * @return
    */
    private int size(BinaryNode<T> subtree){
       if (subtree == null)
           return 0;
       else
       {
           //对比汉诺塔:H(n)=H(n-1) + 1 + H(n-1)
           return size(subtree.left) + 1 + size(subtree.right);
       }
    }
```

**二叉树的遍历**

这个应该不用详细介绍了，刷力扣的题目会经常用到

递归遍历如下：

```java
@Override
    public String preOrder() {
        String sb = preOrder(root);

        if(sb.length() > 0){ //删除尾部的,

            sb = sb.substring(0, sb.length()-1);
        }

        return sb;
    }

    public String preOrder(BinaryNode<T> node){
        StringBuffer sb = new StringBuffer();

        if (node ==null) {//递归结束条件
            return "";
        }
            //先访问根结点
            sb.append(node.data+",");
            //遍历左子树
            sb.append(preOrder(node.left));
            //遍历右子树
            sb.append(preOrder(node.right));

        return sb.toString();

    }

@Override
    public String inOrder() {
        String sb  = inOrder(root);
        if(sb.length() > 0){

            //删除尾部节点
            sb = sb.substring(0, sb.length()-1);

        }
        return sb;
    }

    public String inOrder(BinaryNode<T> node){

        StringBuffer sb = new StringBuffer();

        if(node==null){
            return "";
        }
            sb.append(inOrder(node.left));
            sb.append(node.data + ",");
            sb.append(inOrder(node.right));
        return sb.toString();
    }


 @Override
    public String postOrder() {
        String sb = postOrder(root);
        if(sb.length() > 0){
            sb = sb.substring(0, sb.length()-1);
        }
        return sb;
    }

    public String postOrder(BinaryNode<T> node){
        StringBuffer sb = new StringBuffer();
        if(node == null){
            return "";
        }

        sb.append(postOrder(node.left));
        sb.append(postOrder(node.right));
        sb.append(node.data + ",");
        return sb.toString();
    }
```

非递归遍历如下：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public static void preOrderInteration(TreeNode head){
    if(head == null){
        return;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(head);
    while(!stack.isEmpty()){
		TreeNode node = stack.pop();
        System.out.print(node.val + "");
        if(node.right != null){
			stack.push(node.right);
        }
        if(node.left != null){
			stack.push(node.left);
        }
    }
}

public static void inOrderIteration(TreeNode head){
    if(head == null){
		return;
    }
    TreeNode cur = head;
    Stack<TreeNode> stack = new Stack<>();
    while(!stack.isEmpty() || cur != null){
        while(cur != null){
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();
		System.out.print(node.value + " ");
		if (node.right != null) {
			cur = node.right;
		}
    }
}

public static void postOrderIteration(TreeNode head) {
		if (head == null) {
			return;
		}
		Stack<TreeNode> stack1 = new Stack<>();
		Stack<TreeNode> stack2 = new Stack<>();
		stack1.push(head);
		while (!stack1.isEmpty()) {
			TreeNode node = stack1.pop();
			stack2.push(node);
			if (node.left != null) {
				stack1.push(node.left);
			}
			if (node.right != null) {
				stack1.push(node.right);
			}
		}
		while (!stack2.isEmpty()) {
			System.out.print(stack2.pop().value + " ");
		}
	}
```

还有一种叫Morris算法，在这里就不介绍了

层次遍历代码：

```java
    @Override
    public String levelOrder() {

        LinkedList<BinaryNode<T>> queue = new LinkedList<>();
        StringBuffer sb = new StringBuffer();
        BinaryNode<T> node = root;

        while(node!=null){

            sb.append(node.data + ",");

            if(node.left!=null){
                queue.add(node.left);
            }
            if(node.right!= null){
                queue.add(node.right);
            }
            node = queue.poll();
        }

        return sb.toString().substring(0, sb.length()-1);
    }
```

#### 二叉树查找树全部代码

整个代码如下：

```java
package src.Tree.BinaryTree;


import java.beans.BeanInfo;
import java.net.StandardSocketOptions;
import java.util.EmptyStackException;
import java.util.LinkedList;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-11-25 2:44
 * @Version : 1.0
 */
public class BinarySearchTree<T extends Comparable> implements Tree<T> {

    protected BinaryNode<T> root;

    @Override
    public boolean isEmpty() {
        return root == null;
    }

    @Override
    public int size() {
        return size(root);
    }

    public int size(BinaryNode<T> node){

        if(node == null){
            return 0;
        }else{
            return size(node.right) + 1 + size(node.left);
        }

    }

    @Override
    public int height() {
        return height(root);
    }

    public int height(BinaryNode<T> node){

        if(root == null){
            return 0;
        }else{
            int left = height(node.left);
            int right = height(node.right);
            return (left - right) > 0 ? left + 1: right + 1; //加上当前层
        }

    }

    @Override
    public String preOrder() {
        String sb = preOrder(root);

        if(sb.length() > 0){ //删除尾部的,

            sb = sb.substring(0, sb.length()-1);
        }

        return sb;
    }

    public String preOrder(BinaryNode<T> node){
        StringBuffer sb = new StringBuffer();

        if (node ==null) {//递归结束条件
            return "";
        }
            //先访问根结点
            sb.append(node.data+",");
            //遍历左子树
            sb.append(preOrder(node.left));
            //遍历右子树
            sb.append(preOrder(node.right));

        return sb.toString();

    }

    @Override
    public String inOrder() {
        String sb  = inOrder(root);
        if(sb.length() > 0){

            //删除尾部节点
            sb = sb.substring(0, sb.length()-1);

        }
        return sb;
    }

    public String inOrder(BinaryNode<T> node){

        StringBuffer sb = new StringBuffer();

        if(node==null){
            return "";
        }
            sb.append(inOrder(node.left));
            sb.append(node.data + ",");
            sb.append(inOrder(node.right));
        return sb.toString();
    }

    @Override
    public String postOrder() {
        String sb = postOrder(root);
        if(sb.length() > 0){
            sb = sb.substring(0, sb.length()-1);
        }
        return sb;
    }

    public String postOrder(BinaryNode<T> node){
        StringBuffer sb = new StringBuffer();
        if(node == null){
            return "";
        }

        sb.append(postOrder(node.left));
        sb.append(postOrder(node.right));
        sb.append(node.data + ",");
        return sb.toString();
    }

    @Override
    public String levelOrder() {

        LinkedList<BinaryNode<T>> queue = new LinkedList<>();
        StringBuffer sb = new StringBuffer();
        BinaryNode<T> node = root;

        while(node!=null){

            sb.append(node.data + ",");

            if(node.left!=null){
                queue.add(node.left);
            }
            if(node.right!= null){
                queue.add(node.right);
            }
            node = queue.poll();
        }

        return sb.toString().substring(0, sb.length()-1);
    }

    @Override
    public void insert(T data) {

        if(data == null)
            throw new RuntimeException("data can\'Comparable be null");
        //插入操作
        root = insert(data, root);

    }

    /**
     * 插入操作
     * @param data
     */
    private BinaryNode<T> insert(T data, BinaryNode<T> node){
        if(node == null){
            node = new BinaryNode<T>(data, null, null);
        }

        //比较插入节点的值，决定插入方向
        int compareResult = data.compareTo(node.data);

        if(compareResult < 0){
            node.left = insert(data, node.left);
        }else if(compareResult > 0){
            node.right = insert(data, node.right);
        }else{
            ;//
        }
        return node;
    }

    @Override
    public void remove(T data) {

        if(data == null)
            throw new RuntimeException("data can\'Comparable be null");

        //删除操作
        root = remove(data, root);

    }

    private BinaryNode<T> remove(T data, BinaryNode<T> node){

        if(node == null){
            return node;
        }

        int CompareResult = data.compareTo(node.data);

        if(CompareResult < 0){
            node.left = remove(data, node.left);
        }else if(CompareResult > 0){
            node.right = remove(data, node.right);
        }else if(node.left != null && node.right != null){  //判断是否有两个子节点

            //将要删除的节点用该节点右节点的最小值替换
            node.data = findMin(node.right).data;
            //移除用于替换的节点
            node.right = remove(node.data, node.right);

        }else{  //拥有一个孩子节点

            node = (node.left != null) ? node.left : node.right;
        }

        return node;

    }


    /**
     * 非递归删除
     * @return
     */
    public T removeUnrecure(T data){

        if(data == null)
            throw new RuntimeException("data can\'Comparable be null !");

        //从根节点开始查找
        BinaryNode<T> current = this.root;
        //记录父节点
        BinaryNode<T> parent = this.root;

        //判断左右孩子的flag
        boolean isLeft = true;

        //找到要删除的节点
        while( data.compareTo(current.data)!=0){
            //更新父节点
            parent = current;
            int result = data.compareTo(current.data);

            if(result < 0){ //从左子树
                isLeft = true;
                current = current.left;
            }else if(result > 0){
                isLeft = false;
                current = current.right;
            }

            if(current == null){
                return null;
            }
        }

        //找到了要删除的节点

        //删除的是叶子节点
        if (current.left == null && current.right == null){
            if(current == this.root){
                this.root = null;
            }else if(isLeft){
                parent.left= null;
            }else{
                parent.right = null;
            }
        }


        //删除带有一个孩子的节点，当current的right不为null
        else if(current.left == null){

            if(current == root){
                this.root = current.right;
            }else if(isLeft){ //current为parent的左子节点

                parent.left = current.right;

            }else{

                parent.right = current.right;
            }

        }

        //删除带有一个孩子的节点，当current的left不为null
        else if (current.right == null){

            if(current == root){
                this.root = current.left;
            }else if(isLeft) {
                parent.left = current.left;
            }else{
                parent.right = current.left;
            }
        }

        //删除两个节点的
        else{

            //找到当前要删除节点current的右子树中的最小值
            BinaryNode<T> successor = finSuccessor(current);

            if(current == root){
                this.root = successor;
            }else  if(isLeft){
                parent.left = successor;
            }else{
                parent.right = successor;
            }
            //把当前要删除的结点的左孩子赋值给successor
            successor.left = current.left;

        }

        return current.data;
    }

    /**
     * 查找右子节点最小值
     * @return
     */
    public BinaryNode<T> finSuccessor(BinaryNode<T> delNode){

        BinaryNode<T> successor = delNode;
        BinaryNode<T> successorParent = delNode;
        BinaryNode<T> current = delNode.right;

        //不断查找左结点,直到为空,则successor为最小值结点
        while(current != null) {
            successorParent = successor;
            successor = current;
            current = current.left;
        }
        //如果要删除结点的右孩子与successor不相等,则执行如下操作(如果相当,则说明删除结点)
        if(successor != delNode.right) {
            successorParent.left = successor.right;
            //把中继结点的右孩子指向当前要删除结点的右孩子
            successor.right = delNode.right;
        }
        return successor;
    }

    @Override
    public T findMax() {
        if(isEmpty())
            throw new RuntimeException("BinarySearchTree is empty!");
        return findMax(root).data;

    }

    public BinaryNode<T> findMax(BinaryNode<T> node){

        if(node == null){
            return null;
        }if(node.right == null){
            return node;
        }

        return findMax(node.right);

    }


    @Override
    public T findMin() {
        if(isEmpty())
            throw new RuntimeException("BinarySearchTree is empty!");

        return findMin(root).data;
    }

    /**
     * 查找最小值节点
     * @param node
     * @return
     */
    public BinaryNode<T> findMin(BinaryNode<T> node){

        if(node == null){
            return null;
        }else if(node.left == null){  //如果没有左节点
            return node;
        }
        return findMin(node.left);

    }

    @Override
    public BinaryNode findNode(T data) {

        BinaryNode res = findNode(data, root);

        if (res == null) {
            System.out.println("not found");
            return new BinaryNode(-1);
        } else {
            return res;

        }
    }

    public BinaryNode findNode(T data, BinaryNode<T> node){

        if(node == null){
            return null;
    }

        int compareResult = data.compareTo(node.data);

        //System.out.println(compareResult);

        if(compareResult < 0){
            findNode(data, node.left);
        }else if(compareResult > 0){
            findNode(data, node.right);
        }else{
            return node;
        }

        return null;
    }

    @Override
    public boolean contains(T data) {

        boolean res = contains(data, root);

        if (!res) {
            System.out.println("not found");
            return false;
        } else {
            return true;

        }

    }

    public boolean contains(T data, BinaryNode<T> node){

        if(node == null){
            return false;
        }

        int compareResult = data.compareTo(node.data);

        //System.out.println(compareResult);

        if(compareResult < 0){
            contains(data, node.left);
        }else if(compareResult > 0){
            contains(data, node.right);
        }else{
            return true;
        }

        return false;
    }

    @Override
    public void clear() {
        root = null;
    }

    public static void main(String[] args) {
        BinaryNode<Integer> root = new BinaryNode<>(2);
        BinarySearchTree<Integer> bTree = new BinarySearchTree<Integer>();
        bTree.insert(3);
        bTree.insert(4);
        bTree.insert(2);
        bTree.insert(1);

        bTree.remove(3);

        System.out.println(bTree.preOrder());  //3,2,1,4
        System.out.println(bTree.inOrder());  //1,2,3,4
        System.out.println(bTree.postOrder());  //1,2,4,3
        System.out.println(bTree.levelOrder());  //3,2,4,1
        System.out.println(bTree.findNode(3).data);  //-1
        System.out.println(bTree.contains(3));  //-1
    }

}

```



## 完全二叉树

明白了层次遍历算法后，我们可以利用层次遍历算法来构建一棵完全二叉树，为什么是完全二叉树而不是二叉树呢？完全二叉树继承于二叉查找树，可以用层次遍历进行构建。

<img src="C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203193542640.png" alt="image-20201203193542640" style="zoom:67%;" />

```java
package src.Tree.BinaryTree;

import java.util.LinkedList;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-11-25 20:29
 * @Version : 1.0
 */
public class CompleteBinaryTree<T extends Comparable> extends BinarySearchTree<T>{


    /**
     * 构造空的完全二叉树
     */
    public CompleteBinaryTree(){
        super();
    }

    /**
     * 以层次遍历的形式建立完全二叉树
     * @param levelOrderArray
     */
    public CompleteBinaryTree(T[] levelOrderArray){
        this.root = create(levelOrderArray, 0);
    }

    /**
     * 建树
     * @param levelOrderArray
     * @param i
     * @return
     */
    public BinaryNode<T> create(T[] levelOrderArray, int i){

        if(levelOrderArray ==null){
            throw new RuntimeException("the param 'array' of create method can\'t be null !");
        }

        BinaryNode<T> p = null;

        if (i < levelOrderArray.length){//递归结束条件
            p=new BinaryNode<>(levelOrderArray[i],null,null);
            p.left=create(levelOrderArray,2*i+1);  //根据完全二叉树的性质 2*i+1 为左孩子结点
            p.right=create(levelOrderArray,2*i+2); //2*i+2 为右孩子结点
        }
        return p;

    }

    /**
     * 搜索二叉树的包含操作和移除操作不适合层次遍历构造的完全二叉树
     * 根据层次遍历构建的二叉树必须用层次遍历来判断(仅适用层次遍历构建的完全二叉树)
     * @param data
     * @return
     */
    @Override
    public boolean contains(T data) {
        /**
         * 存放需要遍历的结点,左结点一定优先右节点遍历
         */
        LinkedList<BinaryNode<T>> queue = new LinkedList<>();
        StringBuffer sb=new StringBuffer();
        BinaryNode<T> p=this.root;

        while (p!=null){

            //判断是否存在data
            if(data.compareTo(p.data)==0){
                return true;
            }

            //先按层次遍历结点,左结点一定在右结点之前访问
            if(p.left!=null){
                //孩子结点入队
                queue.add(p.left);
            }

            if (p.right!=null){
                queue.add(p.right);
            }
            //访问下一个结点
            p=queue.poll();
        }

        return false;
    }

    /**
     * 搜索二叉树的包含操作和移除操作不适合层次遍历构造的完全二叉树
     * @param data
     * @return
     */
    @Override
    public void remove(T data) {
        //do nothing 取消删除操作
    }

    /**
     * 完全二叉树只通过层次遍历来构建,取消insert操作
     * @param data
     */
    @Override
    public void insert(T data) {
        //do nothing //取消insert操作
    }

    /**
     * 测试
     * @param args
     */
    public static void main(String args[])
    {

        String[] levelorderArray = {"A","B","C","D","E","F"};
        CompleteBinaryTree<String> cbtree = new CompleteBinaryTree<>(levelorderArray);
        System.out.println("先根遍历:"+cbtree.preOrder());
        //System.out.println("非递归先根遍历:"+cbtree.preOrderTraverse());
        System.out.println("中根遍历:"+cbtree.inOrder());
        //System.out.println("非递归中根遍历:"+cbtree.inOrderTraverse());
        System.out.println("后根遍历:"+cbtree.postOrder());
        //System.out.println("非递归后根遍历:"+cbtree.postOrderTraverse());
        System.out.println("查找最大结点(根据搜索二叉树):"+cbtree.findMax());
        System.out.println("查找最小结点(根据搜索二叉树):"+cbtree.findMin());
        System.out.println("判断二叉树中是否存在E:"+cbtree.contains("E"));

    }
}
```



## 平衡二叉树

### 背景

![image-20201203193905867](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203193905867.png)

当数据出现极端情况的时候，此时的二叉搜索树就变成了一个链表，并不能做到减少时间，此时候平衡二叉树就出来了。

### 定义

> 定义：一棵AVL树是其每个结点的左子树和右子树的高度最多相差1的二叉查找树(空树的高度为-1)，这个差值也称为平衡因子

![image-20201203194440852](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203194440852.png)

### 平衡二叉树代码

#### 平衡二叉树节点定义

根平常树有点不一样，树节点多了一个当前节点的高度

```java
package com.zejian.structures.Tree.AVLTree;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-11-26 20:29
 * @Version : 1.0
 */
public class AVLNode<T extends Comparable> {

    public AVLNode<T> left;//左结点

    public AVLNode<T> right;//右结点

    public T data;

    public int height;//当前结点的高度

    public AVLNode(T data) {
        this(null,null,data);
    }

    public AVLNode(AVLNode<T> left, AVLNode<T> right, T data) {
        this(left,right,data,0);
    }

    public AVLNode(AVLNode<T> left, AVLNode<T> right, T data, int height) {
        this.left=left;
        this.right=right;
        this.data=data;
        this.height = height;
    }
}
```

这里约定空结点（空子树）的高度为-1，叶子结点的高度为0，非叶子节点的高度则根据其子树的高度而计算获取，如下图：

<img src="C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203195311112.png" alt="image-20201203195311112" style="zoom:50%;" />

#### 平衡二叉树插入定义

由于任意结点的孩子结点最多有两个，而且导致失衡的必要条件是X结点的两棵子树高度差为2(大于1)，因此一般只有以下4种情况可能导致X点失去平衡：

- 在结点X的左孩子结点的左子树中插入元素
-  在结点X的左孩子结点的右子树中插入元素
-  在结点X的右孩子结点的左子树中插入元素
-  在结点X的右孩子结点的右子树中插入元素

第①情况和第④情况是对称的，可以通过**单旋转**来解决

第②种情况和第③情况是对称的，需要**双旋转**来解决

##### 平衡二叉树单旋转算法实现

> 一般情况下，我们把X结点称为失衡点，修复一棵被破坏的AVL树时，找到失衡点是很重要的并把通过一次旋转即可修复平衡的操作叫做单旋转

- 左左单旋转(LL)

![image-20201203195644574](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203195644574.png)

![image-20201203195705339](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203195705339.png)

代码实现如下：

```java
/**
 * 左左单旋转(LL旋转) w变为x的根结点, x变为w的右子树
 * @param x
 * @return
 */
private AVLNode<T> singleRotateLeft(AVLNode<T> x){
    //把w结点旋转为根结点
    AVLNode<T> w=  x.left;
    //同时w的右子树变为x的左子树
    x.left=w.right;
    //x变为w的右子树
    w.right=x;
    //重新计算x/w的高度
    x.height=Math.max(height(x.left),height(x.right))+1;
    w.height=Math.max(height(w.left),x.height)+1;
    return w;//返回新的根结点
}
```

- 右右单旋转(RR)

![image-20201203201334421](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203201334421.png)

![image-20201203201350386](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203201350386.png)

代码实现：

```java
    /**
     * 右右单旋转(RR旋转) x变为w的根结点, w变为x的左子树
     * @return
     */
    private AVLNode<T> singleRotateRight(AVLNode<T> w){

        //把w的右节点为根节点
        AVLNode<T> x = w.right;
        //将x的左子树给w的右子树
        w.right = x.left;
        //将x的左子树指向w
        x.left = w;

        //重新计算x/w的高度
        w.height=Math.max(height(w.left),height(w.right))+1;
        x.height=Math.max(height(x.left),w.height)+1;

        //返回新的根结点
        return x;
    }
```

##### 平衡二叉树的双旋转算法与实现

![image-20201203202012845](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203202012845.png)

这种情况下是单旋转没办法生效的。其实就是最深子树在最左最右的时候可以使用单螺旋，但是最深子树在中间的时候，无论如何单旋转都无法实现。

- 左右双旋转(LR)

![image-20201203202242145](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203202242145.png)

![image-20201203202255172](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203202255172.png)

在左右双旋转实例图123中，在原AVL树种插入结点7后，结点8变成了失衡点，此时需要把6结点变为根结点才能重新恢复平衡。因此先进行左向旋转再进行右向旋转，最后树恢复平衡。算法代码实现如下：

```java
/**
 * 左右旋转(LR旋转) x(根) w y 结点 把y变成根结点
 * @return
 */
private AVLNode<T> doubleRotateWithLeft(AVLNode<T> x){
    //w先进行RR旋转
    x.left=singleRotateRight(x.left);
    //再进行x的LL旋转
    return singleRotateLeft(x);
}
```

- 右左双旋转(RL)

![image-20201203202401667](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203202401667.png)

![image-20201203202414071](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203202414071.png)

代码如下：

```java
/**
 * 右左旋转(RL旋转)
 * @param w
 * @return
 */
private AVLNode<T> doubleRotateWithRight(AVLNode<T> x){
    //先进行LL旋转
    x.right=singleRotateLeft(x.right);
    //再进行RR旋转java
    return singleRotateRight(x);
}
```

##### 平衡二叉树插入方法的实现

根二叉查找树一样，先进行插入，再进行平衡判断，最后决定要不要旋转。

```java
    public AVLNode<T> insert(T data, AVLNode<T> node){
        
        if(node == null){
            node = new AVLNode<T>(data);
        }else if(data.compareTo(node.data) < 0){
            node.left = insert(data, node.left);
            
            //插入后计算子树的高度，等于2则需要重新恢复平衡；由于是左边插入，左子树的高度肯定大于右子树的高度
            if(height(node.left) - height(node.right) == 2){
                
                //判断插入节点是左还是右
                if(data.compareTo(node.left.data) < 0){
                    //进行LL旋转
                    node = singleRotateRight(node);
                }else {
                    //进行左右旋转
                    node = doubleRotateWithLeft(node);
                }
            }
            
        }else if(data.compareTo(node) > 0){
            
            node.right = insert(data, node.right);
            
            if(height(node.right) - height(node.left) == 2){
                
                if(data.compareTo(node.right.data) < 0){
                    
                    node = doubleRotateWithRight(node);
                }else{
                    node = singleRotateRight(node);
                }
            }
            
        }
        
        else ;
        
        node.height = Math.max(height(node.left), height(node.right)) + 1;
        
        return node;
    }
```

#### 平衡二叉树删除定义

二叉查找树中删除方法的实现类似，但是在移除结点后需要进行平衡检测，以便判断是否需要进行平衡修复。

```java
@Override
    public void remove(T data) {
        if(data == null)
            throw new RuntimeException("data can not be null");

        this.root = remove(data, root);
    }

    public AVLNode<T> remove(T data, AVLNode<T> node){
        if(node == null)
            return null;

        int result = data.compareTo(node.data);

        if(result < 0) {
            node.left = remove(data, node.left);

            //检测是否平衡
            if (height(node.right) - height(node.left) == 2) {
                AVLNode<T> currentNode = node.right;
                //判断需要那种旋转
                if (height(currentNode.left) > height(currentNode.right)) {
                    //RL
                    node = doubleRotateWithRight(node);
                } else {
                    //RR
                    node = singleRotateRight(node);
                }
            }
        }

        //从右子树查找需要删除的元素
        else if(result>0){
            node.right=remove(data,node.right);
            //检测是否平衡
            if(height(node.left)-height(node.right)==2){
                AVLNode<T> currentNode=node.left;
                //判断需要那种旋转
                if(height(currentNode.right)>height(currentNode.left)){
                    //LR
                    node=doubleRotateWithLeft(node);
                }else{
                    //LL
                    node=singleRotateLeft(node);
                }
            }

        }

        //已找到需要删除的元素,并且要删除的结点拥有两个子节点
        else if(node.right!=null&&node.left!=null){
            //寻找替换结点
            node.data=findMin(node.right).data;
            //移除用于替换的结点
            node.right = remove( node.data, node.right );
        }
        else {
            //只有一个孩子结点或者只是叶子结点的情况
            node=(node.left!=null)? node.left:node.right;
        }

        //更新高度值
        if(node!=null)
            node.height = Math.max( height(node.left ), height( node.right ) ) + 1;
        return node;
    }
```

其他方法都跟前面实现的二叉查找树的接口是一样的。

#### 平衡二叉树全部代码

代码如下：

```java
package src.Tree.AVLTree;

import src.Link.ArrayList;
import src.Tree.BinaryTree.BinaryNode;
import src.Tree.BinaryTree.BinarySearchTree;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-03 20:00
 * @Version : 1.0
 */
public class AVLTree <T extends Comparable> implements Tree<T> {

    public AVLNode<T> root;

    @Override
    public boolean isEmpty() {
        return root==null;
    }


    @Override
    public int size() {
        return size(root);
    }


    public int size(AVLNode<T> subtree){
        if(subtree==null){
            return 0;
        }else {
            return size(subtree.left) + 1 + size(subtree.right);
        }


    }


    @Override
    public int height() {
        return height(root);
    }


    /**
     * @param p
     * @return
     */
    public int height(AVLNode<T> p){
        return p == null ? -1 : p.height;
    }


    @Override
    public String preOrder() {
        String sb=preOrder(root);
        if(sb.length()>0){
            //去掉尾部","号
            sb=sb.substring(0,sb.length()-1);
        }
        return sb;
    }

    /**
     * 先根遍历
     * @param subtree
     * @return
     */
    public String preOrder(AVLNode<T> subtree){
        StringBuilder sb =new StringBuilder();
        if (subtree!=null) {
            //先访问根结点
            sb.append(subtree.data).append(",");
            //访问左子树
            sb.append(preOrder(subtree.left));
            //访问右子树
            sb.append(preOrder(subtree.right));
        }
        return sb.toString();
    }

    @Override
    public String inOrder() {
        String sb=inOrder(root);
        if(sb.length()>0){
            //去掉尾部","号
            sb=sb.substring(0,sb.length()-1);
        }
        return sb;
    }

    /**
     * 中根遍历
     * @param subtree
     * @return
     */
    private String inOrder(AVLNode<T> subtree){
        StringBuilder sb =new StringBuilder();
        if (subtree!=null) {
            //访问左子树
            sb.append(inOrder(subtree.left));
            //访问根结点
            sb.append(subtree.data).append(",");
            //访问右子树
            sb.append(inOrder(subtree.right));
        }
        return sb.toString();
    }

    @Override
    public String postOrder() {
        String sb=postOrder(root);
        if(sb.length()>0){
            //去掉尾部","号
            sb=sb.substring(0,sb.length()-1);
        }
        return sb;
    }

    /**
     * 后根遍历
     * @param subtree
     * @return
     */
    private String postOrder(AVLNode<T> subtree){
        StringBuilder sb =new StringBuilder();
        if (subtree!=null){
            //访问左子树
            sb.append(postOrder(subtree.left));
            //访问右子树
            sb.append(postOrder(subtree.right));
            //访问根结点
            sb.append(subtree.data).append(",");
        }
        return sb.toString();
    }

    @Override
    public String levelOrder() {
        /**
         * @see BinarySearchTree#levelOrder()
         * @return
         */
        return null;
    }


    @Override
    public void insert(T data) {

        if(data == null)
            throw new RuntimeException("data is not be null");

        this.root = insert(data, root);

    }


    public AVLNode<T> insert(T data, AVLNode<T> node){

        if(node == null){
            node = new AVLNode<T>(data);
        }

        int result = data.compareTo(node.data);

        if(result < 0){
            node.left = insert(data, node.left);

            //插入后计算子树的高度，等于2则需要重新恢复平衡；由于是左边插入，左子树的高度肯定大于右子树的高度
            if(height(node.left) - height(node.right) == 2){

                //判断插入节点是左还是右
                if(data.compareTo(node.left.data) < 0){
                    //进行LL旋转
                    node = singleRotateRight(node);
                }else {
                    //进行左右旋转
                    node = doubleRotateWithLeft(node);
                }
            }

        }else if(result > 0){

            node.right = insert(data, node.right);

            if(height(node.right) - height(node.left) == 2){

                if(data.compareTo(node.right.data) < 0){

                    node = doubleRotateWithRight(node);
                }else{
                    node = singleRotateRight(node);
                }
            }

        }

        else ;

        node.height = Math.max(height(node.left), height(node.right)) + 1;

        return node;
    }


    /**
     * 查找最小值结点
     * @param p
     * @return
     */
    private AVLNode<T> findMin(AVLNode<T> p){
        if (p==null)//结束条件
            return null;
        else if (p.left==null)//如果没有左结点,那么t就是最小的
            return p;
        return findMin(p.left);
    }

    @Override
    public T findMin() {
        return findMin(root).data;
    }

    @Override
    public T findMax() {
        return findMax(root).data;
    }

    /**
     * 查找最大值结点
     * @param p
     * @return
     */
    private AVLNode<T> findMax(AVLNode<T> p){
        if (p==null)
            return null;
        else if (p.right==null)//如果没有右结点,那么t就是最大的
            return p;
        return findMax(p.right);
    }

    @Override
    public BinaryNode findNode(T data) {
        /**
         * @see BinarySearchTree#findNode(Comparable)
         * @return
         */
        return null;
    }

    @Override
    public boolean contains(T data) {
        return data != null && contain(data, root);
    }

    public boolean contain(T data , AVLNode<T> subtree){

        if (subtree==null)
            return false;

        int result =data.compareTo(subtree.data);

        if (result<0){
            return contain(data,subtree.left);
        }else if(result>0){
            return contain(data,subtree.right);
        }else {
            return true;
        }
    }

    @Override
    public void clear() {
        this.root=null;
    }


    /**
     * 左左单旋转（LL旋转）W变为x的根节点，x变为w的右子树
     * @param x
     * @return
     */
    private AVLNode<T> singleRotateLeft(AVLNode<T> x){

        //把w结点旋转为根节点
        AVLNode<T> w = x.left;
        //同时把w的右子树变成x的左子树
        x.left = w.right;
        //把x变成w的右子树
        w.right = x;
        //重新解释x/w的高度
        x.height = Math.max(height(x.left), height(x.right)) + 1;
        w.height = Math.max(height(w.left), x.height)+1;
        return w;
    }

    /**
     * 右右单旋转(RR旋转) x变为w的根结点, w变为x的左子树
     * @return
     */
    private AVLNode<T> singleRotateRight(AVLNode<T> w){

        //把w的右节点为根节点
        AVLNode<T> x = w.right;
        //将x的左子树给w的右子树
        w.right = x.left;
        //将x的左子树指向w
        x.left = w;

        //重新计算x/w的高度
        w.height=Math.max(height(w.left),height(w.right))+1;
        x.height=Math.max(height(x.left),w.height)+1;

        //返回新的根结点
        return x;
    }

    /**
     * 左右旋转(LR旋转) x(根) w y 结点 把y变成根结点
     * @return
     */
    private AVLNode<T> doubleRotateWithLeft(AVLNode<T> x){
        //w先进行RR旋转
        x.left=singleRotateRight(x.left);
        //再进行x的LL旋转
        return singleRotateLeft(x);
    }


    /**
     * 右左旋转(RL旋转)
     * @param x
     * @return
     */
    private AVLNode<T> doubleRotateWithRight(AVLNode<T> x){
        //先进行LL旋转
        x.right=singleRotateLeft(x.right);
        //再进行RR旋转java
        return singleRotateRight(x);
    }


    @Override
    public void remove(T data) {
        if(data == null)
            throw new RuntimeException("data can not be null");

        this.root = remove(data, root);
    }

    public AVLNode<T> remove(T data, AVLNode<T> node){
        if(node == null)
            return null;

        int result = data.compareTo(node.data);

        if(result < 0) {
            node.left = remove(data, node.left);

            //检测是否平衡
            if (height(node.right) - height(node.left) == 2) {
                AVLNode<T> currentNode = node.right;
                //判断需要那种旋转
                if (height(currentNode.left) > height(currentNode.right)) {
                    //RL
                    node = doubleRotateWithRight(node);
                } else {
                    //RR
                    node = singleRotateRight(node);
                }
            }
        }

        //从右子树查找需要删除的元素
        else if(result>0){
            node.right=remove(data,node.right);
            //检测是否平衡
            if(height(node.left)-height(node.right)==2){
                AVLNode<T> currentNode=node.left;
                //判断需要那种旋转
                if(height(currentNode.right)>height(currentNode.left)){
                    //LR
                    node=doubleRotateWithLeft(node);
                }else{
                    //LL
                    node=singleRotateLeft(node);
                }
            }

        }

        //已找到需要删除的元素,并且要删除的结点拥有两个子节点
        else if(node.right!=null&&node.left!=null){
            //寻找替换结点
            node.data=findMin(node.right).data;
            //移除用于替换的结点
            node.right = remove( node.data, node.right );
        }
        else {
            //只有一个孩子结点或者只是叶子结点的情况
            node=(node.left!=null)? node.left:node.right;
        }

        //更新高度值
        if(node!=null)
            node.height = Math.max( height(node.left ), height( node.right ) ) + 1;
        return node;
    }




    private void printTree( AVLNode<T> t ) {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.data );
            printTree( t.right );
        }
    }

    /**
     * 测试
     * @param arg
     */
    public  static void main(String arg[]){

        AVLTree<Integer> avlTree=new AVLTree<>();

        for (int i = 1; i <18 ; i++) {
            avlTree.insert(i);
        }

        avlTree.printTree(avlTree.root);
        //删除11,8以触发旋转平衡操作
        avlTree.remove(11);
        avlTree.remove(8);

        System.out.println("================");

        avlTree.printTree(avlTree.root);

        System.out.println("findMin:"+avlTree.findMin());

        System.out.println("findMax:"+avlTree.findMax());

        System.out.println("15 exist or not : " + avlTree.contains(15) );

        System.out.println("先根遍历:"+avlTree.preOrder());

        System.out.println("中根遍历:"+avlTree.inOrder());

        System.out.println("后根遍历:"+avlTree.postOrder());
    }
}
```

## 哈夫曼树

### 定义

Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。

给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。

### 概念

<img src="C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201203214149857.png" alt="image-20201203214149857" style="zoom:50%;" />

- 路径和路径长度

  > 在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径，简单可以看有几条线。
  >
  > 100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。

- 结点的权及带权路径长度

  > 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
  >
  > 节点20的路径长度是3，它的带权路径长度= 路径长度 * 权 = 3 * 20 = 60。

- 树的带权路径长度

  > 树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。
  >
  > 树的WPL= 1*100 + 2*80 + 3*20 + 3*10 = 100 + 160 + 60 + 30 = 350。

### 建树理论

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/03.jpg?raw=true)

```
哈夫曼树是一个自底向上构建的二叉树。
首先得到：5  6  7  8  15 (从小到大排序)
最小的两个数相加： 11  7  8  15 
再排序:  7  8  11  15 
相加:  15 11  15
排序:  11  15  15
相加:  26  15
排序： 15 26
相加:  41
```

#### 哈夫曼树接口定义

因为哈夫曼树是自底向上建立接口的，所以树的接口相对有一些改动，需要在每个方法面前导入节点。

```java
package src.Tree.HuffmanTree;


/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-11-25 2:27
 * @Version : 1.0
 */
public interface Tree<T extends Comparable> {

    /**
     * 判断是否为空
     */
    boolean isEmpty(HuffmanNode node);

    /**
     * 二叉树结点个数
     */
    int size(HuffmanNode node);

    /**
     * 返回二叉树的高度或者深度，即结点的最大层次
     */
    int height(HuffmanNode node);

    /**
     * 前序遍历
     *
     */
    String preOrder(HuffmanNode node);

    /**
     * 中序遍历
     *
     */
    String inOrder(HuffmanNode node);

    /**
     * 后序遍历
     */
    String postOrder(HuffmanNode node);

    /**
     * 层次遍历
     */
    String levelOrder( HuffmanNode node);
    
}
```

#### 哈夫曼节点类定义

哈夫曼需要用权值进行建树，所以在存储data的基础上还需要一个值来存储权值，故：

```java
package src.Tree.HuffmanTree;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-03 22:00
 * @Version : 1.0
 */
public class HuffmanNode<T> implements Comparable<HuffmanNode>{

    public T data;  //节点的权
    public HuffmanNode<T> left;  //左子节点
    public HuffmanNode<T> right;  //右子节点
    public int weight;

    public  HuffmanNode(){};


    public HuffmanNode(T data, int weight, HuffmanNode left, HuffmanNode right){
        this.data = data;
        this.left = left;
        this.right = right;
        this.weight = weight;
    }

    public HuffmanNode(T data, int weight){
        this(data, weight, null, null);
    }

    @Override
    public String toString() {
        return "TreeNode[data=" + data + ", weight=" + weight + "]";
    }

    @Override
    public int compareTo(HuffmanNode o) {
        return this.weight - o.weight;
    }
}

```

#### 哈夫曼树创建定义

这里需要使用到小顶堆(优先队列的定义)，创建树思路如上：

```java
package src.Tree.HuffmanTree;
import java.util.*;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-03 22:06
 * @Version : 1.0
 */
public class HuffmanTree implements Tree{

    public static HuffmanNode createHuffmanTree(ArrayList<HuffmanNode> huffmanNodeList){

        PriorityQueue<HuffmanNode> pq = new PriorityQueue<>();

        for(HuffmanNode  node : huffmanNodeList){
            pq.add(node);
        }

        while (pq.size()>1){

            HuffmanNode left = pq.poll();
            HuffmanNode right = pq.poll();
            HuffmanNode root = new HuffmanNode(null, left.weight + right.weight, left, right);
            pq.add(root);
        }

        return pq.poll();

    }

    @Override
    public int size(HuffmanNode node) {
        if(node == null){
            return 0;
        }else{
            return size(node.right) + 1 + size(node.left);
        }
    }



    @Override
    public int height(HuffmanNode node) {
        if(node == null){
            return 0;
        }else{
            int left = height(node.left);
            int right = height(node.right);
            return (left - right) > 0 ? left + 1: right + 1; //加上当前层
        }
    }


    @Override
    public boolean isEmpty(HuffmanNode root) {
        return root == null;
    }


    @Override
    public String preOrder(HuffmanNode node) {

        StringBuffer sb = new StringBuffer();

        if (node ==null) {//递归结束条件
            return "";
        }
        //先访问根结点
        sb.append(node.weight+",");
        //遍历左子树
        sb.append(preOrder(node.left));
        //遍历右子树
        sb.append(preOrder(node.right));

        return sb.toString().substring(0, sb.length()-1);
    }



    @Override
    public String inOrder(HuffmanNode node) {

        StringBuffer sb = new StringBuffer();

        if(node==null){
            return "";
        }
        sb.append(inOrder(node.left));
        sb.append(node.weight + ",");
        sb.append(inOrder(node.right));
        return sb.toString().substring(0, sb.length()-1);
    }


    @Override
    public String postOrder(HuffmanNode node) {
        StringBuffer sb = new StringBuffer();
        if(node == null){
            return "";
        }

        sb.append(postOrder(node.left));
        sb.append(postOrder(node.right));
        sb.append(node.weight + ",");
        return sb.toString().substring(0, sb.length()-1);
    }


    @Override
    public  String levelOrder(HuffmanNode root) {

        LinkedList<HuffmanNode> queue = new LinkedList<>();
        StringBuffer sb = new StringBuffer();
        HuffmanNode node = root;

        while(node!=null){

            sb.append(node.weight + ",");

            if(node.left!=null){
                queue.add(node.left);
            }
            if(node.right!= null){
                queue.add(node.right);
            }
            node = queue.poll();
        }

        return sb.toString().substring(0, sb.length()-1);
    }



    public static void main(String[] args) {

        HuffmanTree huffmanTree = new HuffmanTree();
        ArrayList<HuffmanNode> list = new ArrayList<>();
        list.add(new HuffmanNode("A", 1));
        list.add(new HuffmanNode("B", 1));
        list.add(new HuffmanNode("C", 3));
        list.add(new HuffmanNode("D", 4));
        list.add(new HuffmanNode("E", 5));
        list.add(new HuffmanNode("F", 6));
        HuffmanNode root = createHuffmanTree(list);

        System.out.println(huffmanTree.levelOrder(root));
    }
}

```



## B树

### 背景

- 为什么不用二叉树进行查找？二叉树的查找速度和比较次数都是最小的，但是现实的问题是：磁盘IO

- 当数据库的索引大小超过了几G，这时候不能把整个索引加载到内存，只能够逐一加载每一个磁盘页（也就是索引树节点）

  <img src="C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204152321755.png" alt="image-20201204152321755" style="zoom: 67%;" />

  <img src="C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204152359336.png" alt="image-20201204152359336" style="zoom:50%;" />

  **情景假设**此时假设我们用二叉查找树作为索引结构，假设树的高度是4，查找的值是10：

  ![image-20201204152532186](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204152532186.png)

  ```
  9 -> 13 -> 11 -> 10
  ```

  磁盘IO次数就是由 **树的深度决定的**

### 定义

B树就是B-树，中间的横线不是减号(不可以读成B减树)。B树是一种多路平衡查找树，它的每个节点最多包含K个孩子，K被称为B树的阶。K的大小取决于磁盘页的大小。

下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征：

- 根结点至少有两个子女。
- 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
- 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
- 所有的叶子结点都位于同一层。
- 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

**是不是很懵逼，看不下去，继续往下看：**

3阶B树

![image-20201204153005323](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204153005323.png)

```
查询5:  9 ->  2 6 ->  3 5
```

查询比较的次数相比于磁盘IO 的次数，内存中的消耗几乎可以忽略，所以只要树的高度足够低，IO次数足够少，就可提升查找性能。

**优点**

- 磁盘IO快
- 自平衡

**引用**

> B-树主要应用于文件系统以及部分数据索引，比如著名的MongoDB。
>
> 大部分关系型数据库，比如Mysql则是使用B+树作为索引。

#### B树节点的定义

节点需要三个变量，分别是： 

- 关键字

  ```
  叶点信息的数量
  就是一个节点可以存放的。每个节点的大小为一个磁盘的页，节点中锁包含的关键字及其子节点的数目取决于页的大小。
  ```

- 内结点的子节点

  ```
  用于储存该节点的子节点信息
  因为自己点不一定是只有一个，所以需要用一个链表来存储子节点信息
  ```

- 父节点

  ```
  指向父节点的信息
  ```

其中除了简单的构造方法之外还需要加上如下方法：

```
addChildren(List<BTNode> children) 设置父节点批量添加多个孩子结点，然后排序
searchKey() 在结点node中搜索关键字key
addChild(BTNode child)  设置父节点批量添加单个孩子结点，然后排序
removeChild(BTNode childNode) 删除孩子结点
```

代码如下：

```java
package src.Tree.BTree;

import java.util.*;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-04 17:42
 * @Version : 1.0
 */
public class BTNode {

    private List<Integer> keys;
    private List<BTNode> childNodes;            //内结点的子结点
    private BTNode parent;

    public BTNode() {
        keys = new LinkedList<Integer>();
        childNodes = new ArrayList<BTNode>();
    }

    public BTNode(BTNode parent) {
        this();
        this.parent = parent;
    }

    public BTNode getParentNode() {
        return parent;
    }


    public void setParentNode(BTNode parentNode) {
        this.parent = parentNode;


    }

    public List<Integer> getKeys() {
        return keys;
    }

    public Integer getKey(int index) {
        return keys.get(index);
    }

    public void setKeys(List<Integer> keys) {
        this.keys = keys;
    }

    public void setChildNodes(List<BTNode> childNodes) {
        this.childNodes = childNodes;
    }

    public List<BTNode> getChildNodes() {
        return childNodes;
    }

    public BTNode getChild(int index) {
        return childNodes.get(index);
    }

    /**
     * 设置父节点并批量添加孩子结点,添加后需要排序
     *
     * @param children
     * @return boolean
     */
    public boolean addChildren(List<BTNode> children) {
        for (BTNode node : children) {
            node.setParentNode(this);
        }

        childNodes.addAll(children);

        //排序
        Collections.sort(childNodes, new Comparator<BTNode>() {

            @Override
            public int compare(BTNode o1, BTNode o2) {
                return o1.getKeys().get(0).compareTo(o2.getKeys().get(0));
            }
        });
        return true;
    }

    public void addKey(Integer key) {
        SearchResult searchResult = searchKey(this, key);
        this.getKeys().add(searchResult.getIndex(), key);


    }

    /**
     * 在结点node中搜索关键字key
     * @param node BTNode
     * @param key Integer
     * @return
     */
    public SearchResult searchKey(BTNode node, Integer key)
    {
        boolean result = false;
        int index;

        List<Integer> keys = node.getKeys();

        int low = 0 ;
        int high = keys.size() - 1;
        int mid = 0;
        while(low <= high)
        {
            mid = (low + high) >>> 1;
            Comparable<Integer> midVal = keys.get(mid);
            int cmp = midVal.compareTo(key);

            if(cmp < 0)
                low = mid + 1;
            else if(cmp > 0)
                high = mid - 1;
            else {
                break;
            }
        }

        if(low <= high){//查找成功
            result = true;
            index = mid;
        }else{
            index = low;
        }

        return new SearchResult(result, index);
    }

    /**
     * 设置父节点并添加孩子结点,添加后需要排序
     * @param child
     * @return boolean
     */
    public boolean addChild(BTNode child)
    {
        child.setParentNode(this);

        childNodes.add(child);

        //排序
        Collections.sort(childNodes, new Comparator<BTNode>() {
            @Override
            public int compare(BTNode o1, BTNode o2) {
                return o1.getKeys().get(0).compareTo(o2.getKeys().get(0));
            }
        });

        return true;
    }

    /**
     * 删除孩子结点
     * @param childNode
     */
    public void removeChild(BTNode childNode) {
        childNodes.remove(childNode);
    }

    /**
     * @return 结点中关键字个数
     */
    public int sizeOfKeys() {
        return keys.size();
    }

    /**
     * @return 孩子个数
     */
    public int sizeOfChildren() {
        return childNodes.size();
    }

}
```

#### B树查找类定义

- 在B树节点中搜索给定键值的返回结果。

- 该结果由两部分组成。第一部分表示此次查找是否成功

- 如果查找成功,第二部分表示给定键值在B树节点中的位置

- 如果查找失败,第二部分表示给定键值应该插入的位置。

```java
package src.Tree.BTree;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-04 17:48
 * @Version : 1.0
 */
public class SearchResult {

    private boolean result;
    private int index;

    public SearchResult(boolean result, int index) {
        super();
        this.result = result;  //是否查找成功
        this.index = index;   //指定键值
    }

    /**
     * @return 给定键值在B树节点中的位置或者给定键值应该插入的位置
     */
    public int getIndex() {
        return index;
    }

    /**
     * @return 查找是否成功
     */
    public boolean getResult(){
        return result;
    }
}

```

#### B树阶数定义

```
定义如下：
1. k 阶数定义，比如3阶
2. minkey 最小关键字定义： ceil(k/2 - 1) 比如 1
3. maxkey 最大关键字定义:  k-1 比如 2
4. minChild 最小的孩子个数: ceil(k/2) 比如 2
5. maxChild 最大的孩子个数: k 比如 3
```

```java
package src.Tree.BTree;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-04 17:49
 * @Version : 1.0
 */
public class Constants {

    /**
     * BTree的阶<br>
     * BTree中关键字个数为[ceil(m/2)-1,m-1]	<br> 向上取整
     * BTree中子树个数为[ceil(m/2),m]
     */
    public static final int BTREE_ORDER = 3;

    /**
     * 非根节点中最小的关键字个数
     */
    public static final int MIN_KEY_SIZE = (int) (Math.ceil(Constants.BTREE_ORDER / 2.0) - 1);

    /**
     * 非根节点中最大的关键字个数
     */
    public static final int MAX_KEY_SIZE = Constants.BTREE_ORDER - 1;

    /**
         * 每个结点中最小的孩子个数
     */
    public static final int MIN_CHILDREN_SIZE = (int) (Math.ceil(Constants.BTREE_ORDER / 2.0));

    /**
     * 每个结点中最大的孩子个数
     */
    public static final int MAX_CHILDREN_SIZE = Constants.BTREE_ORDER ;
}
```

#### B树创建定义

主要函数如下：

```
newInstance()  初始化函数，创建一个B树
insertKey(Integer key) 插入关键字
removeKey(Integer key) 删除关键字
findNode(Integer key) 查找key函数
insertKeys(Integer[] keys) 插入关键字数组
```

##### B树插入实现

插入主要考虑两种情况：

- 是叶子节点
  - 插入后如果超出最大个数，则分裂，否则则插入
- 不是叶子节点
  - 找到对应区间的下一个结点，采用了二叉搜索的查找思想
  - 调用是否是叶子节点

分裂主要如下图所示：

- 一棵B树如图所示

![image-20201204191355477](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204191355477.png)

- 此时插入key值为26的节点

![image-20201204191447847](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204191447847.png)

- 当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点，结果如下图所示。

![image-20201204191546646](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204191546646.png)

- 进位后导致当前结点（即根结点）也需要分裂，分裂的结果如下图所示。

![image-20201204191607808](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204191607808.png)

插入代码如下：

```java
/**
     * 向BTree中插入关键字<p>
     * 从根节点开始寻找最佳的插入结点,若为叶子结点,则先插入key然后判断是否需要分裂;
     * 若为非叶子结点,则从上到下寻找最佳的叶子结点,然后重复上面叶子结点的情况
     * @param key Integer
     * @return boolean 是否插入成功
     */
    public boolean insertKey(Integer key){
        BTNode node = root;

        while (node != null){ //从根节点开始往下查找
        
            if (node.sizeOfChildren() == 0){ //叶子节点
            
                node.addKey(key); //因为每次加入都会进行排序所以不用担心
                if (node.sizeOfKeys() <= Constants.MAX_KEY_SIZE){
            
                    break;
                } else { //插入关键字之后其个数大于最大size,需要进行分裂
                    splitNode(node);
                    break;
                }
            } else { //非叶子结点
                Integer lesser = node.getKey(0);
                if (key.compareTo(lesser) < 0) { //比最小的关键字还小
                    node = node.getChild(0);//则关键字必定插入到它最左边的子树上
                    continue;
                }

                int size = node.sizeOfKeys();
                int last = size - 1;
                Integer greater = node.getKey(last);
                if (key.compareTo(greater) > 0) {//比最大的关键字还大
                    node = node.getChild(size);//则关键字必定插入到它最右边的子树上
                    continue;
                }

                //若不属于上述两种情况则需要一步步查找中间结点
                for (int i = 1; i < node.sizeOfKeys(); i++){
                    Integer prev = node.getKey(i - 1);
                    Integer next = node.getKey(i);
                    if (key.compareTo(prev) > 0 && key.compareTo(next) < 0)
                    {
                        node = node.getChild(i);
                        break;
                    }
                }
            }
        }

        sizeOfKeys ++;
        return true;
    }
```

**分裂操作**

```
1. 得到 node.sizeOfKeys() / 2的关键字，因为要从中间开始分裂
2. 生成一个新的左结点，将前一半的关键字存入，并且根据关键字大小接入子节点
3. 生成一个新的右节点，将后一半的关键字存入，并且根据关键字大小接入子节点
4. 判断有没有父节点，有的话则将node.sizeOfKeys() / 2的关键字插入，判断是否超过最大关键字数，是的话递归分裂；没有的话新建一个结点最为根结点。
```

代码如下：

```java
 /**
     * 从叶子节点开始从下到上递归分裂
     * @param node BTNode
     * @param
     */
    private void splitNode(BTNode node)
    {
        //分裂位置发生在size/2,分裂成两个结点
        int splitIndex = node.sizeOfKeys() / 2;
        //需要上移的关键字
        Integer splitKey = node.getKeys().get(splitIndex);


        //生成新的结点
        BTNode left = new BTNode(null);

        for(int i = 0 ; i < splitIndex; i ++)
        {
            left.addKey(node.getKey(i));
        }
        if(node.sizeOfChildren() > 0)
        {
            left.addChildren(node.getChildNodes().subList(0, splitIndex + 1));//这里索引需要注意
        }

        BTNode right = new BTNode(null);
        for(int i = splitIndex + 1; i < node.sizeOfKeys(); i ++)
        {
            right.addKey(node.getKey(i));
        }
        if(node.sizeOfChildren() > 0)
        {
            right.addChildren(node.getChildNodes().subList(splitIndex + 1, node.sizeOfChildren()));
        }

        if(node.getParentNode() != null)//有父节点
        {
            BTNode parent = node.getParentNode();//取得其父节点
            parent.addKey(splitKey);
            parent.removeChild(node);
            parent.addChild(left);
            parent.addChild(right);

            if(parent.sizeOfKeys() > Constants.MAX_KEY_SIZE)
            {
                splitNode(parent);
            }

        }else{//没有父节点,即到达根节点
            BTNode newRoot = new BTNode(null);
            newRoot.getKeys().add(splitKey);
            root = newRoot;
            newRoot.addChild(left);
            newRoot.addChild(right);
        }
    }
```

##### B 树删除实现

```
首先，通过关键字找到在哪个节点中。
1. 该节点是非叶子节点:
	(1) 删除其中的key值
	(2) 左孩子最大结点中的最大的元素并删除(简称取过来)
	(3) 添加到删除了key的节点中
	(4) 判断左孩子节点会不会小于最下关键字个数，如果小则合并
2. 该节点是叶子节点：
	(1)既是叶子结点又是根节点且 node.sizeOfKeys() < Constants.MIN_KEY_SIZE
    (2)叶子结点但非根结点且node.sizeOfKeys() < Constants.MIN_KEY_SIZE	----->只有这一种需要合并
    (3)既是叶子结点又是根节点且node.sizeOfKeys() > Constants.MIN_KEY_SIZE
    (4)叶子结点但非根结点且node.sizeOfKeys() > Constants.MIN_KEY_SIZE
```

**非叶子节点**

![image-20201204194531991](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204194531991.png)

在上述情况下接着删除27。从上图可知27位于非叶子结点中，所以用27的后继替换它。从图中可以看出，27的后继为28，我们用28替换27，然后在28（原27）的右孩子结点中删除28。删除后的结果如下图所示。

![image-20201204194752218](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204194752218.png)

删除后发现，当前叶子结点的记录的个数小于2，而它的兄弟结点中有3个记录（当前结点还有一个右兄弟，选择右兄弟就会出现合并结点的情况，不论选哪一个都行，只是最后B树的形态会不一样而已），我们可以从兄弟结点中借取一个key。所以父结点中的28下移，兄弟结点中的26上移,删除结束。

![image-20201204194830498](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204194830498.png)

**删除为叶子节点(只写需要合并的情况）**

![image-20201204195005093](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204195005093.png)

在上述情况下接着32

![image-20201204195024706](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204195024706.png)

当删除后，当前结点中只key，而兄弟结点中也仅有2个key。所以只能让父结点中的30下移和这个两个孩子结点中的key合并，成为一个新的结点，当前结点的指针指向父结点。

![image-20201204195101305](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204195101305.png)



代码如下：

```java
public boolean removeKey(Integer key)
    {
        //先找到关键字在哪个结点中,如果没有找到此结点则直接返回false
        BTNode node = this.findNode(key);
        if(node == null)
            return false;

        int index = node.getKeys().indexOf(key);//获取此key的索引
        node.getKeys().remove(key);//删除此key

        if(node.sizeOfChildren() != 0)//非叶子结点
        {
            BTNode left = node.getChild(index);//左孩子
            BTNode greatest = this.getGreatestNode(left);

            //获取并删除左孩子最大结点中的最大的元素
            Integer replaceValue = greatest.getKeys().remove(greatest.sizeOfKeys() - 1);
            //将此元素添加到删除关键字key的结点中
            node.addKey(replaceValue);

            //如果删除关键字后导致下溢,则需要合并结点
            if(greatest.sizeOfKeys() < Constants.MIN_KEY_SIZE)
            {
                this.combined(greatest);	//greatest为叶子结点
            }

        }else{//叶子结点
            //分为四种情况:
            //1)既是叶子结点又是根节点且 node.sizeOfKeys() < Constants.MIN_KEY_SIZE
            //2)叶子结点但非根结点且node.sizeOfKeys() < Constants.MIN_KEY_SIZE	----->只有这一种需要合并
            //3)既是叶子结点又是根节点且node.sizeOfKeys() > Constants.MIN_KEY_SIZE
            //4)叶子结点但非根结点且node.sizeOfKeys() > Constants.MIN_KEY_SIZE
            if(node.getParentNode() != null && node.sizeOfKeys() < Constants.MIN_KEY_SIZE)
            {
                this.combined(node);
            }else if(node.getParentNode() == null && node.sizeOfKeys() == 0)
            {
                //删除的是最后一个元素
                root = null;
            }

        }
        sizeOfKeys --;
        return true;
    }
```

**合并操作**

```
根据结点找到对应的左邻居右邻居
1. 此结点的右邻居存在且右邻居结点中关键字个数 >= minSize + 1      相当于左旋	
2. 此结点的左邻居存在且左邻居结点中关键字个数 >= minSize + 1     相当于右旋 		
3. 此结点的右邻居存在且父节点关键字个数大于0	 结点合并	
4. 此结点的左邻居存在且父节点关键字个数大于0	 结点合并	
```

代码如下：

```java
    /**
     * 此node结点中关键字个数不足，需要合并结点，与splitNode()方法类似，也是从叶节点开始向上递归的。<p>
     * 需要分情况讨论：	<br>
     * 1) 此结点的右邻居存在且右邻居结点中关键字个数 >= minSize + 1      相当于左旋
     * 2) 此结点的左邻居存在且左邻居结点中关键字个数 >= minSize + 1   相当于右旋 		
     * 3) 此结点的右邻居存在且父节点关键字个数大于0	 结点合并	
     * 4) 此结点的左邻居存在且父节点关键字个数大于0	 结点合并	
     * @param node BTNode
     */
    private void combined(BTNode node)
    {
        //先获取此结点的父节点
        BTNode parentNode = node.getParentNode();
        //获取此结点是其父节点中的索引，即第几个孩子
        int index = parentNode.getChildNodes().indexOf(node);
        int indexOfLeftNeighbor = index - 1;
        int indexOfRightNeighbor = index + 1;

        BTNode rightNeighbor = null;
        int rightNeighborSize = 0; 
        if(indexOfRightNeighbor < parentNode.sizeOfChildren())//右邻居存在
        {
            rightNeighbor = parentNode.getChild(indexOfRightNeighbor);
            rightNeighborSize = rightNeighbor.sizeOfKeys();
        }

        //右邻居存在且其关键字个数大于最小值
        if(rightNeighbor != null && rightNeighborSize > Constants.MIN_KEY_SIZE)
        {
            //相当于左旋
            Integer removeValue = rightNeighbor.getKeys().remove(0);
            int prev = getIndexOfPreviousValue(parentNode, removeValue);
            Integer parentValue = parentNode.getKeys().remove(prev);
            node.addKey(parentValue);
            parentNode.addKey(removeValue);

            if(rightNeighbor.sizeOfChildren() > 0)//如果右邻居的孩子结点存在，则需要把右邻居的第一个孩子结点删除并添加到node结点中
            {
                node.addChild(rightNeighbor.getChildNodes().remove(0));
            }
        }else{
            BTNode leftNeighbor = null;
            int leftNeighborSize = 0;//???
            if(indexOfLeftNeighbor >= 0)//左邻居存在
            {
                leftNeighbor = parentNode.getChild(indexOfLeftNeighbor);
                leftNeighborSize = leftNeighbor.sizeOfKeys();
            }

            //左邻居存在且其关键字个数大于最小值
            if(leftNeighbor != null && leftNeighborSize > Constants.MIN_KEY_SIZE)//左邻居存在且其关键字个数大于最小值
            {
                //相当于右旋
                Integer removeValue = leftNeighbor.getKeys().remove(leftNeighbor.sizeOfKeys() - 1);
                int next = getIndexOfNextValue(parentNode, removeValue);
                Integer parentValue = parentNode.getKeys().remove(next);
                node.addKey(parentValue);
                parentNode.addKey(removeValue);

                if(leftNeighbor.sizeOfChildren() > 0)//如果左邻居的孩子结点存在，则需要把右邻居的最后一个孩子结点删除并添加到node结点中
                {
                    node.addChild(leftNeighbor.getChildNodes().remove(leftNeighbor.sizeOfChildren() - 1));
                }

            }else if(rightNeighbor != null && parentNode.sizeOfKeys() > 0)//右邻居存在且父节点关键字个数大于0
            {
                Integer rightValue = rightNeighbor.getKey(0);//获取右邻居结点中最左边的关键字
                int prev = getIndexOfPreviousValue(parentNode, rightValue);//获取rightValue关键字的父节点中不大于但最接近此关键字的索引
                Integer parentKey = parentNode.getKeys().remove(prev);//在父节点中删除此索引对应的关键字
                parentNode.removeChild(rightNeighbor); // 在父节点中删除此索引对应的孩子结点
                node.addKey(parentKey);//将删除的关键字添加到关键字下溢的结点中

                //将右邻居中的关键字添加进去
                for(int i = 0 ; i < rightNeighbor.sizeOfKeys(); i ++)
                {
                    node.addKey(rightNeighbor.getKey(i));
                }

                //将右邻居中的孩子结点也添加进去
                for(int i = 0 ; i < rightNeighbor.sizeOfChildren(); i ++)
                {
                    node.addChild(rightNeighbor.getChild(i));
                }

                if(parentNode.getParentNode() != null && parentNode.sizeOfKeys() < Constants.MIN_KEY_SIZE)//还没到达根节点
                {
                    this.combined(parentNode);

                }else if(parentNode.sizeOfKeys() == 0){
                    //父节点中没有关键字了，则降低树的高度
                    node.setParentNode(null);//注意：树的高度降低一层，此结点就变为根节点，一定要设置其父节点为null
                    parentNode = null;
                    root = node;
                }

            }else if(leftNeighbor != null && parentNode.sizeOfKeys() > 0)	//左邻居存在且父节点关键字个数大于0
            {
                Integer leftValue = leftNeighbor.getKey(leftNeighbor.sizeOfKeys() - 1);//获取左邻居结点中最右边的关键字
                int next = getIndexOfNextValue(parentNode, leftValue);//获取leftValue关键字的父节点中不小于但最接近此关键字的索引
                Integer parentKey = parentNode.getKeys().remove(next);//在父节点中删除此索引对应的关键字
                parentNode.removeChild(leftNeighbor); //在父节点中删除此索引对应的孩子结点
                node.addKey(parentKey);//将删除的关键字添加到关键字下溢的结点中

                //将左邻居中的关键字添加进去
                for(int i = 0 ; i < leftNeighbor.sizeOfKeys(); i ++)
                {
                    node.addKey(leftNeighbor.getKey(i));
                }

                //将左邻居中的孩子结点也添加进去
                for(int i = 0 ; i < leftNeighbor.sizeOfChildren(); i ++)
                {
                    node.addChild(leftNeighbor.getChild(i));
                }

                if(parentNode.getParentNode() != null && parentNode.sizeOfKeys() < Constants.MIN_KEY_SIZE)//还没到达根节点
                {
                    this.combined(parentNode);

                }else if(parentNode.sizeOfKeys() == 0){
                    //父节点中没有关键字了，则降低树的高度
                    node.setParentNode(null);//注意：树的高度降低一层，此结点就变为根节点，一定要设置其父节点为null
                    parentNode = null;
                    root = node;
                }
            }
        }//end else
    }
```

所有代码如下：

```java
package src.Tree.BTree;

import java.util.List;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-04 17:49
 * @Version : 1.0
 */
public class BTree {

    private BTNode root;			//Btree的根节点
    private int sizeOfKeys;			//Btree中关键字个数

    /**
     * 默认情况下只有一个节点且为叶子结点
     */
    private BTree()
    {
        root = new BTNode(null);//根节点没有父节点
    }

    private static BTree instance = new BTree();

    /**
     * 创建BTree
     * @return BTree
     */
    public static BTree newInstance()
    {
        return instance;
    }

    /**
     * 向BTree中插入关键字<p>
     * 从根节点开始寻找最佳的插入结点,若为叶子结点,则先插入key然后判断是否需要分裂;
     * 若为非叶子结点,则从上到下寻找最佳的叶子结点,然后重复上面叶子结点的情况
     * @param key Integer
     * @return boolean 是否插入成功
     */
    public boolean insertKey(Integer key)
    {
        BTNode node = root;

        while (node != null) //从根节点开始往下查找
        {
            if (node.sizeOfChildren() == 0) //叶子节点
            {
                node.addKey(key);
                if (node.sizeOfKeys() <= Constants.MAX_KEY_SIZE)
                {
                    break;
                } else {//插入关键字之后其个数大于最大size,需要进行分裂
                    splitNode(node);
                    break;
                }
            } else {//非叶子结点
                Integer lesser = node.getKey(0);
                if (key.compareTo(lesser) < 0) {//比最小的关键字还小
                    node = node.getChild(0);//则关键字必定插入到它最左边的子树上
                    continue;
                }

                int size = node.sizeOfKeys();
                int last = size - 1;
                Integer greater = node.getKey(last);
                if (key.compareTo(greater) > 0) {//比最大的关键字还大
                    node = node.getChild(size);//则关键字必定插入到它最右边的子树上
                    continue;
                }

                //若不属于上述两种情况则需要一步步查找中间结点
                for (int i = 1; i < node.sizeOfKeys(); i++)
                {
                    Integer prev = node.getKey(i - 1);
                    Integer next = node.getKey(i);
                    if (key.compareTo(prev) > 0 && key.compareTo(next) < 0)
                    {
                        node = node.getChild(i);
                        break;
                    }
                }
            }
        }

        sizeOfKeys ++;
        return true;
    }


    /**
     * 删除BTree中关键字。先找到关键字在哪个结点中,如果没有找到此结点则直接返回false，
     * 如果此结点存在再对该结点分叶子结点和非叶子结点讨论：<br>
     * <br>
     * 对于叶子结点：<br>
     * 1)既是叶子结点又是根节点且 node.sizeOfKeys() < Constants.MIN_KEY_SIZE<br>
     * 2)叶子结点但非根结点且node.sizeOfKeys() < Constants.MIN_KEY_SIZE	----->只有这一种需要合并<br>
     * 3)既是叶子结点又是根节点且node.sizeOfKeys() > Constants.MIN_KEY_SIZE<br>
     * 4)叶子结点但非根结点且node.sizeOfKeys() > Constants.MIN_KEY_SIZE<br>
     * 5)实际只需讨论两种情况<br>
     * <br>
     * 对于非叶子结点:<br>
     * 1)先获取关键字key在所在的结点中的关键字列表keys中的索引,删除该关键字key<br>
     * 2)获取并删除左孩子最大结点greatest中的最大的元素,此元素在叶节点中,即用左孩子中最大的关键字填补被删除的关键字key<br>
     * 3)如果greatest结点中的关键字个数不足则需要合并结点<br>
     * <p>
     * 首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，
     * 如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的
     * 某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之
     * 后的情况；如果没有，直接删除后，移动之后的情况。删除元素，移动相应元素之后，
     * 如果某结点中元素数目（即关键字数）小于ceil(m/2)-1，则需要看其某相邻兄弟结点是
     * 否丰满（结点中元素个数大于ceil(m/2)-1）（还记得第一节中关于B树的第5个特性中的
     * c点么?： c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足：
     * (ceil(m / 2)-1)<= n <= m-1。m表示最多含有m个孩子，n表示关键字数。
     *例如 在一颗5阶B树的示例中，关键字数n满足：2<=n<=4），如果丰满，则向父节点
     * 借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，
     * 则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。
     * @param key Integer
     * @return True if value was removed from the tree.
     */
    public boolean removeKey(Integer key)
    {
        //先找到关键字在哪个结点中,如果没有找到此结点则直接返回false
        BTNode node = this.findNode(key);
        if(node == null)
            return false;

        int index = node.getKeys().indexOf(key);//获取此key的索引
        node.getKeys().remove(key);//删除此key

        if(node.sizeOfChildren() != 0)//非叶子结点
        {
            BTNode left = node.getChild(index);//左孩子
            BTNode greatest = this.getGreatestNode(left);

            //获取并删除左孩子最大结点中的最大的元素
            Integer replaceValue = greatest.getKeys().remove(greatest.sizeOfKeys() - 1);
            //将此元素添加到删除关键字key的结点中
            node.addKey(replaceValue);

            //如果删除关键字后导致下溢,则需要合并结点
            if(greatest.sizeOfKeys() < Constants.MIN_KEY_SIZE)
            {
                this.combined(greatest);	//greatest为叶子结点
            }

        }else{//叶子结点
            //分为四种情况:
            //1)既是叶子结点又是根节点且 node.sizeOfKeys() < Constants.MIN_KEY_SIZE
            //2)叶子结点但非根结点且node.sizeOfKeys() < Constants.MIN_KEY_SIZE	----->只有这一种需要合并
            //3)既是叶子结点又是根节点且node.sizeOfKeys() > Constants.MIN_KEY_SIZE
            //4)叶子结点但非根结点且node.sizeOfKeys() > Constants.MIN_KEY_SIZE
            if(node.getParentNode() != null && node.sizeOfKeys() < Constants.MIN_KEY_SIZE)
            {
                this.combined(node);
            }else if(node.getParentNode() == null && node.sizeOfKeys() == 0)
            {
                //删除的是最后一个元素
                root = null;
            }

        }
        sizeOfKeys --;
        return true;
    }


    /**
     * 从上到下直到叶节点找到最大的叶结点
     * @param node BTNode
     * @return BTNode
     */
    private BTNode getGreatestNode(BTNode node)
    {
        while(node.sizeOfChildren() != 0)
        {
            node = node.getChild(node.sizeOfChildren() - 1);
        }
        return node;
    }

    /**
     * 此node结点中关键字个数不足，需要合并结点，与splitNode()方法类似，也是从叶节点开始向上递归的。<p>
     * 需要分情况讨论：	<br>
     * 1) 此结点的右邻居存在且右邻居结点中关键字个数 >= minSize + 1      相当于左旋	♣	<br>
     * 2) 此结点的左邻居存在且左邻居结点中关键字个数 >= minSize + 1   相当于右旋 		♥<br>
     * 3) 此结点的右邻居存在且父节点关键字个数大于0	 结点合并	♠<br>
     * 4) 此结点的左邻居存在且父节点关键字个数大于0	 结点合并	♦<br>
     * @param node BTNode
     */
    private void combined(BTNode node)
    {
        //先获取此结点的父节点
        BTNode parentNode = node.getParentNode();
        //获取此结点是其父节点中的索引，即第几个孩子
        int index = parentNode.getChildNodes().indexOf(node);
        int indexOfLeftNeighbor = index - 1;
        int indexOfRightNeighbor = index + 1;

        BTNode rightNeighbor = null;
        int rightNeighborSize = 0;//???
        if(indexOfRightNeighbor < parentNode.sizeOfChildren())//右邻居存在
        {
            rightNeighbor = parentNode.getChild(indexOfRightNeighbor);
            rightNeighborSize = rightNeighbor.sizeOfKeys();
        }

        //右邻居存在且其关键字个数大于最小值
        if(rightNeighbor != null && rightNeighborSize > Constants.MIN_KEY_SIZE)
        {
            //相当于左旋
            Integer removeValue = rightNeighbor.getKeys().remove(0);
            int prev = getIndexOfPreviousValue(parentNode, removeValue);
            Integer parentValue = parentNode.getKeys().remove(prev);
            node.addKey(parentValue);
            parentNode.addKey(removeValue);

            if(rightNeighbor.sizeOfChildren() > 0)//如果右邻居的孩子结点存在，则需要把右邻居的第一个孩子结点删除并添加到node结点中
            {
                node.addChild(rightNeighbor.getChildNodes().remove(0));
            }
        }else{
            BTNode leftNeighbor = null;
            int leftNeighborSize = 0;//???
            if(indexOfLeftNeighbor >= 0)//左邻居存在
            {
                leftNeighbor = parentNode.getChild(indexOfLeftNeighbor);
                leftNeighborSize = leftNeighbor.sizeOfKeys();
            }

            //左邻居存在且其关键字个数大于最小值
            if(leftNeighbor != null && leftNeighborSize > Constants.MIN_KEY_SIZE)//左邻居存在且其关键字个数大于最小值
            {
                //相当于右旋
                Integer removeValue = leftNeighbor.getKeys().remove(leftNeighbor.sizeOfKeys() - 1);
                int next = getIndexOfNextValue(parentNode, removeValue);
                Integer parentValue = parentNode.getKeys().remove(next);
                node.addKey(parentValue);
                parentNode.addKey(removeValue);

                if(leftNeighbor.sizeOfChildren() > 0)//如果左邻居的孩子结点存在，则需要把右邻居的最后一个孩子结点删除并添加到node结点中
                {
                    node.addChild(leftNeighbor.getChildNodes().remove(leftNeighbor.sizeOfChildren() - 1));
                }

            }else if(rightNeighbor != null && parentNode.sizeOfKeys() > 0)//右邻居存在且父节点关键字个数大于0
            {
                Integer rightValue = rightNeighbor.getKey(0);//获取右邻居结点中最左边的关键字
                int prev = getIndexOfPreviousValue(parentNode, rightValue);//获取rightValue关键字的父节点中不大于但最接近此关键字的索引
                Integer parentKey = parentNode.getKeys().remove(prev);//在父节点中删除此索引对应的关键字
                parentNode.removeChild(rightNeighbor); // 在父节点中删除此索引对应的孩子结点
                node.addKey(parentKey);//将删除的关键字添加到关键字下溢的结点中

                //将右邻居中的关键字添加进去
                for(int i = 0 ; i < rightNeighbor.sizeOfKeys(); i ++)
                {
                    node.addKey(rightNeighbor.getKey(i));
                }

                //将右邻居中的孩子结点也添加进去
                for(int i = 0 ; i < rightNeighbor.sizeOfChildren(); i ++)
                {
                    node.addChild(rightNeighbor.getChild(i));
                }

                if(parentNode.getParentNode() != null && parentNode.sizeOfKeys() < Constants.MIN_KEY_SIZE)//还没到达根节点
                {
                    this.combined(parentNode);

                }else if(parentNode.sizeOfKeys() == 0){
                    //父节点中没有关键字了，则降低树的高度
                    node.setParentNode(null);//注意：树的高度降低一层，此结点就变为根节点，一定要设置其父节点为null
                    parentNode = null;
                    root = node;
                }

            }else if(leftNeighbor != null && parentNode.sizeOfKeys() > 0)	//左邻居存在且父节点关键字个数大于0
            {
                Integer leftValue = leftNeighbor.getKey(leftNeighbor.sizeOfKeys() - 1);//获取左邻居结点中最右边的关键字
                int next = getIndexOfNextValue(parentNode, leftValue);//获取leftValue关键字的父节点中不小于但最接近此关键字的索引
                Integer parentKey = parentNode.getKeys().remove(next);//在父节点中删除此索引对应的关键字
                parentNode.removeChild(leftNeighbor); //在父节点中删除此索引对应的孩子结点
                node.addKey(parentKey);//将删除的关键字添加到关键字下溢的结点中

                //将左邻居中的关键字添加进去
                for(int i = 0 ; i < leftNeighbor.sizeOfKeys(); i ++)
                {
                    node.addKey(leftNeighbor.getKey(i));
                }

                //将左邻居中的孩子结点也添加进去
                for(int i = 0 ; i < leftNeighbor.sizeOfChildren(); i ++)
                {
                    node.addChild(leftNeighbor.getChild(i));
                }

                if(parentNode.getParentNode() != null && parentNode.sizeOfKeys() < Constants.MIN_KEY_SIZE)//还没到达根节点
                {
                    this.combined(parentNode);

                }else if(parentNode.sizeOfKeys() == 0){
                    //父节点中没有关键字了，则降低树的高度
                    node.setParentNode(null);//注意：树的高度降低一层，此结点就变为根节点，一定要设置其父节点为null
                    parentNode = null;
                    root = node;
                }
            }
        }//end else
    }

    /**
     * 返回node结点中值不大于但最接近与value的关键字的索引，都比value大则返回0，都比value小则返回size-1
     * @param node BTNode
     * @param value Integer
     * @return int
     */
    private int getIndexOfPreviousValue(BTNode node, Integer value)
    {
        for (int i = 1; i < node.sizeOfKeys(); i++)
        {
            Integer t = node.getKey(i);
            if (t.compareTo(value) >= 0)
                return i - 1;
        }
        return node.sizeOfKeys() - 1;
    }

    /**
     * 返回node结点中值不小于但最接近与value的关键字的索引，都比value大则返回0，都比value小则返回size-1
     * @param node BTNode
     * @param value Integer
     * @return
     */
    private int getIndexOfNextValue(BTNode node, Integer value)
    {
        for(int i = 0 ; i < node.sizeOfKeys(); i ++)
        {
            Integer t = node.getKey(i);

            if(t.compareTo(value) >= 0)
            {
                return i;
            }
        }
        return node.sizeOfKeys() - 1;
    }

    /**
     * 在BTree中查找key，若存在则返回此BTNode，不存在则返回null
     * @param key Integer
     * @return BTNode
     */
    public BTNode findNode(Integer key)
    {
        BTNode node = root;

        while(node != null)
        {
            if(node.sizeOfChildren() == 0)//叶子结点
            {
                if(node.getKeys().contains(key))
                {
                    return node;
                }
                return null;

            }else{//非叶子结点
                if(key.compareTo(node.getKey(0)) < 0)//比最小的小
                {
                    node = node.getChild(0);
                    continue;
                }

                if(key.compareTo(node.getKey(node.sizeOfKeys() - 1)) > 0)//比最大的还大
                {
                    node = node.getChild(node.sizeOfKeys());
                    continue;
                }

                //中间情况
                for(int i = 1 ;i < node.sizeOfKeys(); i ++)
                {
                    if(key.compareTo(node.getKey(i)) == 0)
                    {
                        return node;
                    }else if(key.compareTo(node.getKey(i - 1)) > 0 && key.compareTo(node.getKey(i)) < 0)
                    {
                        node = node.getChild(i);
                        break;
                    }
                }

            }
        }
        return null;
    }

    /**
     * @return BTree中关键字个数
     */
    public int sizeOfKeys()
    {
        return sizeOfKeys;
    }


    /**
     * 从叶子节点开始从下到上递归分裂
     * @param node BTNode
     * @param
     */
    private void splitNode(BTNode node)
    {
        //分裂位置发生在size/2,分裂成两个结点
        int splitIndex = node.sizeOfKeys() / 2;
        //需要上移的关键字
        Integer splitKey = node.getKeys().get(splitIndex);

//		List<Integer> copy1 = new ArrayList<>(node.getKeys().subList(0, splitIndex));//---2
//		List<Integer> copy2 = new ArrayList<>(node.getKeys().subList(splitIndex + 1, node.getKeys().size()));//----2

        //生成新的结点
        BTNode left = new BTNode(null);
//		left.setKeys(node.getKeys().subList(0, splitIndex));
//		left.setKeys(copy1);	//-----2
        for(int i = 0 ; i < splitIndex; i ++)
        {
            left.addKey(node.getKey(i));
        }
        if(node.sizeOfChildren() > 0)
        {
            left.addChildren(node.getChildNodes().subList(0, splitIndex + 1));//这里索引需要注意
        }

        BTNode right = new BTNode(null);
//		right.setKeys(node.getKeys().subList(splitIndex + 1, node.getKeys().size()));
//		right.setKeys(copy2);	//----2
        for(int i = splitIndex + 1; i < node.sizeOfKeys(); i ++)
        {
            right.addKey(node.getKey(i));
        }
        if(node.sizeOfChildren() > 0)
        {
            right.addChildren(node.getChildNodes().subList(splitIndex + 1, node.sizeOfChildren()));
        }

        if(node.getParentNode() != null)//有父节点
        {
            BTNode parent = node.getParentNode();//取得其父节点
            parent.addKey(splitKey);
            parent.removeChild(node);
            parent.addChild(left);
            parent.addChild(right);

            if(parent.sizeOfKeys() > Constants.MAX_KEY_SIZE)
            {
                splitNode(parent);
            }

        }else{//没有父节点,即到达根节点
            BTNode newRoot = new BTNode(null);
            newRoot.getKeys().add(splitKey);
            root = newRoot;
            newRoot.addChild(left);
            newRoot.addChild(right);
        }
    }


    /**
     * 插入关键字数组
     * @param keys Integer[]
     * @return boolean 是否插入成功
     */
    public boolean insertKeys(Integer[] keys)
    {
        boolean isInsert ;
        for(int i = 0 ; i < keys.length; i ++)
        {
            isInsert = insertKey(keys[i]);
            if(! isInsert)
            {
                return false;
            }
        }
        return true;
    }

    /**
     * 插入关键字序列
     * @param keys List
     * @return boolean 是否插入成功
     */
    public boolean insertKeys(List<Integer> keys)
    {
        Integer[] keysArray  = (Integer[]) keys.toArray();
        return insertKeys(keysArray);
    }



    private static class TreePrinter
    {

        public static  String getString(BTree tree)
        {
            if (tree.root == null) return "Tree has no nodes.";
            return getString(tree.root, "", true);
        }

        private static String getString(BTNode node, String prefix, boolean isTail)
        {
            StringBuilder builder = new StringBuilder();

            builder.append(prefix).append((isTail ? "└── " : "├── "));
            for (int i = 0; i < node.sizeOfKeys(); i++) {
                Integer value = node.getKey(i);
                builder.append(value);
                if (i < node.sizeOfKeys() - 1) builder.append(", ");
            }
            builder.append("\n");

            if (node.getChildNodes() != null) {
                for (int i = 0; i < node.sizeOfChildren() - 1; i++) {
                    BTNode obj = node.getChild(i);
                    builder.append(getString(obj, prefix + (isTail ? "    " : "│   "), false));
                }
                if (node.sizeOfChildren() >= 1) {
                    BTNode obj = node.getChild(node.sizeOfChildren() - 1);
                    builder.append(getString(obj, prefix + (isTail ? "    " : "│   "), true));
                }
            }

            return builder.toString();
        }
    }

    public static void main(String[] args)
    {
        BTree bTree = BTree.newInstance();

        for(int i = 1 ; i <= 10; i ++)
        {
            bTree.insertKey(i);
            System.out.println(TreePrinter.getString(bTree));
        }
        for(int i = 10 ; i > 0; i --)
        {
            bTree.removeKey(i);
            System.out.println(TreePrinter.getString(bTree));
        }

    }

}

```



## B+树

### 背景

B+树是基于B-树的一种变体，有着比B-树更高效的查询性能。

### 定义

B+树具有如下特征（看不下去）：

- 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
- 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

B+树的特点（看下去）：

- 每个父节点的元素都出现在子节点中，是子节点的最大(或最小)元素。
- 卫星数据的位置。( 卫星数据，指的是索引元素所指向的数据记录，比如数据库中的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据)

例子如下：

![image-20201204213155035](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204213155035.png)

第一个特点

![image-20201204213319797](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204213319797.png)

第二个特点

B-树中的卫星数据

![image-20201204213920430](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204213920430.png)

B+树种的卫星数据

![image-20201204214008576](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204214008576.png)

需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。



### 查询对比

#### 单行查询

> 在单元素查询的时候，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。

**找3**

第一次磁盘IO

![image-20201204214327310](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204214327310.png)

第二次磁盘IO

![image-20201204214408115](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204214408115.png)

第三次磁盘IO

![image-20201204214427901](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204214427901.png)

```
两点不同：
1. B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。(意味着，数据量相同的情况下，B+树的结构比B-树更加‘矮胖’，因此查询次数更少)
2. B+树的查询必须是最终查找到叶子节点，B-树只要匹配到元素即可，因此B-树查找性能不稳定，B+树查找性能是稳定的
```

#### **范围查找**

**查找3到11**

B-树（中序遍历）：

自顶向下，查找到范围的下限:

![image-20201204214935707](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204214935707.png)

中序遍历到元素6

![image-20201204215002879](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204215002879.png)

中序遍历到元素8:

![image-20201204215036542](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204215036542.png)

中序遍历到元素9:

![image-20201204215114367](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204215114367.png)

中序遍历到元素11，遍历结束：

![image-20201204215145450](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204215145450.png)

B+树（链表上做遍历）：

自顶向下，查找到范围的下限

![image-20201204215245527](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204215245527.png)

通过链表指针，遍历到元素6, 8

![image-20201204215311367](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204215311367.png)

通过链表指针，遍历到元素9, 11，遍历结束

![image-20201204215335216](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204215335216.png)

**B+树比B-树的优势：**

- IO次数更少
- 查询性能更稳定
- 范围查询简便

### 总结

B+树的特征：

1. **有k个子树的中间节点包含有k个元素**（B树中是k-1个元素），每个元素**不保存数据**，只用来索引，所有数据都保存在**叶子节点**。

2. 所有的叶子结点中包含了**全部元素的信息**，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。（链表）

3. 所有的**中间节点元素都同时存在于子节点**，在子节点元素中是最大（或最小）元素。

4. B+树查找时是**从上到下查找**；B-树则是从下往上查找（中序遍历）

### 代码

#### B+树节点定义

对比B-树多了指向前节点和后节点的节点指针

```java
package src.Tree.BPlusTree;

import java.util.List;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-04 22:14
 * @Version : 1.0
 */
public class BPlusNode {

    //节点的子节点
    private List<BPlusNode> BPlusNodes;
    //节点的键值对
    private List<KeyAndValue> keyAndValue;
    //节点的后节点
    private BPlusNode nextBPlusNode;
    //节点的前节点
    private BPlusNode previousBPlusNode;
    //节点的父节点
    private BPlusNode parantBPlusNode;

    public BPlusNode( List<BPlusNode> BPlusNodes, List<KeyAndValue> keyAndValue, BPlusNode nextBPlusNode,BPlusNode previousBPlusNode, BPlusNode parantBPlusNode) {
        this.BPlusNodes = BPlusNodes;
        this.keyAndValue = keyAndValue;
        this.nextBPlusNode = nextBPlusNode;
        this.parantBPlusNode = parantBPlusNode;
        this.previousBPlusNode = previousBPlusNode;
    }

    boolean isLeaf() {
        return BPlusNodes==null;
    }

    boolean isHead() {
        return previousBPlusNode == null;
    }

    boolean isTail() {
        return nextBPlusNode == null;
    }

    boolean isRoot() {
        return parantBPlusNode == null;
    }


    List<BPlusNode> getBPlusNodes() {
        return BPlusNodes;
    }

    void setBPlusNodes(List<BPlusNode> BPlusNodes) {
        this.BPlusNodes = BPlusNodes;
    }


    List<KeyAndValue> getKeyAndValue() {
        return keyAndValue;
    }

//    public void setKeyAndValue(List<KeyAndValue> KeyAndValue) {
//        this.keyAndValue = KeyAndValue;
//    }

    BPlusNode getNextBPlusNode() {
        return nextBPlusNode;
    }

    void setNextBPlusNode(BPlusNode nextBPlusNode) {
        this.nextBPlusNode = nextBPlusNode;
    }

    BPlusNode getParantBPlusNode() {
        return parantBPlusNode;
    }

    void setParantBPlusNode(BPlusNode parantBPlusNode) {
        this.parantBPlusNode = parantBPlusNode;
    }

    BPlusNode getPreviousBPlusNode() {
        return previousBPlusNode;
    }

    void setPreviousBPlusNode(BPlusNode previousBPlusNode) {
        this.previousBPlusNode = previousBPlusNode;
    }
}
```

还需要新建一个类来保存我们的关键字和信息(数据库所属行)

```java
package src.Tree.BPlusTree;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-04 22:16
 * @Version : 1.0
 */

public class KeyAndValue implements Comparable<KeyAndValue>{
    /*存储索引关键字*/
    private int key;
    /*存储数据*/
    private Object value;

    @Override
    public int compareTo(KeyAndValue o) {
        //根据key的值升序排列
        return this.key - o.key;
    }

    public int getKey() {
        return key;
    }

    public void setKey(int key) {
        this.key = key;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    KeyAndValue(int key, Object value) {
        this.key = key;
        this.value = value;
    }
}
```

#### B+树创建定义

##### B+树插入实现

```
分裂操作很像我们的B—树，只是多个一个nextBPlusNode操作
1. 找到要插入的节点
2. 将关键字插入其中，然后判断是否需要分裂，需要的话就分裂
```

**插入不分裂**

![image-20201204230647099](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204230647099.png)

此时插入17：

![image-20201204230719306](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204230719306.png)

**插入分裂**

![image-20201204230719306](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204230719306.png)

插入18：

![image-20201204230806058](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204230806058.png)

当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。

![image-20201204230824579](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204230824579.png)

代码如下：

```java
 public void insert(KeyAndValue entry) {
        List<KeyAndValue> keyAndValues1 = new ArrayList<>();
        //插入第一个节点
        if (head == null) {
            keyAndValues1.add(entry);
            head = new BPlusNode(null, keyAndValues1, null, null, null);
            root = new BPlusNode(null, keyAndValues1, null, null, null);
        } else {
            BPlusNode BPlusNode = head;
            //遍历链表，找到插入键值对对应的节点
            while (BPlusNode != null) {
                List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
                int exitFlag = 0;
                //如果插入的键的值和当前节点键值对集合中的某个键的值相等，则直接替换value
                for (KeyAndValue KV : keyAndValues) {
                    if (KV.getKey() == entry.getKey()) {
                        KV.setValue(entry.getValue());
                        exitFlag = 1;
                        break;
                    }
                }
                //如果插入的键已经有了，则退出循环
                if (exitFlag == 1) {
                    break;
                }
                //如果当前节点是最后一个节点或者要插入的键值对的键的值小于下一个节点的键的最小值，则直接插入当前节点
                if (BPlusNode.getNextBPlusNode() == null || BPlusNode.getNextBPlusNode().getKeyAndValue().get(0).getKey() >= entry.getKey()) {
                    splidBPlusNode(BPlusNode, entry);
                    break;
                }
                //移动指针
                BPlusNode = BPlusNode.getNextBPlusNode();
            }
        }
    }
```

分裂操作代码：

```java
//判断是否需要拆分节点
    private void splidBPlusNode(BPlusNode BPlusNode, KeyAndValue addkeyAndValue) {
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();

        if (keyAndValues.size() == rank - 1) {
            //先插入待添加的节点
            keyAndValues.add(addkeyAndValue);
            Collections.sort(keyAndValues);
            //取出当前节点的键值对集合
            //取出原来的key-value集合中间位置的下标
            int mid = keyAndValues.size() / 2;
            //取出原来的key-value集合中间位置的键
            int midKey = keyAndValues.get(mid).getKey();
            //构造一个新的键值对，不是叶子节点的节点不存储value的信息
            KeyAndValue midKeyAndValue = new KeyAndValue(midKey, "");
            //将中间位置左边的键值对封装成集合对象
            List<KeyAndValue> leftKeyAndValues = new ArrayList<>();
            for (int i = 0; i < mid; i++) {
                leftKeyAndValues.add(keyAndValues.get(i));
            }
            //将中间位置右边边的键值对封装成集合对象
            List<KeyAndValue> rightKeyAndValues = new ArrayList<>();
            //如果是叶子节点则在原节点中保留上移的key-value，否则原节点删除上移的key-value
            int k;
            if (BPlusNode.isLeaf()) {
                k = mid;
            } else {
                k = mid + 1;
            }
            for (int i = k; i < rank; i++) {
                rightKeyAndValues.add(keyAndValues.get(i));
            }
            //对左右两边的元素重排序
            Collections.sort(leftKeyAndValues);
            Collections.sort(rightKeyAndValues);
            //以mid为界限将当前节点分列成两个节点，维护前指针和后指针
            BPlusNode rightBPlusNode;
            BPlusNode leftBPlusNode;
//            if (BPlusNode.isLeaf()) {
            //如果是叶子节点维护前后指针
            rightBPlusNode = new BPlusNode(null, rightKeyAndValues, BPlusNode.getNextBPlusNode(), null, BPlusNode.getParantBPlusNode());
            leftBPlusNode = new BPlusNode(null, leftKeyAndValues, rightBPlusNode, BPlusNode.getPreviousBPlusNode(), BPlusNode.getParantBPlusNode());
            rightBPlusNode.setPreviousBPlusNode(leftBPlusNode);
//            } else {
//                //如果不是叶子不维护前后指针
//                rightBPlusNode = new BPlusNode(null, rightKeyAndValues, null, null, BPlusNode.getParantBPlusNode());
//                leftBPlusNode = new BPlusNode(null, leftKeyAndValues, null, null, BPlusNode.getParantBPlusNode());
//            }
            //如果当前分裂的节点有孩子节点,设置分裂后节点和孩子节点的关系
            if (BPlusNode.getBPlusNodes() != null) {
                //取得所有地孩子节点
                List<BPlusNode> BPlusNodes = BPlusNode.getBPlusNodes();
                List<BPlusNode> leftBPlusNodes = new ArrayList<>();
                List<BPlusNode> rightBPlusNodes = new ArrayList<>();
                for (BPlusNode childBPlusNode : BPlusNodes) {
                    //取得当前孩子节点的最大键值
                    int max = childBPlusNode.getKeyAndValue().get(childBPlusNode.getKeyAndValue().size() - 1).getKey();
                    if (max < midKeyAndValue.getKey()) {
                        //小于mid处的键的数是左节点的子节点
                        leftBPlusNodes.add(childBPlusNode);
                        childBPlusNode.setParantBPlusNode(leftBPlusNode);
                    } else {
                        //大于mid处的键的数是右节点的子节点
                        rightBPlusNodes.add(childBPlusNode);
                        childBPlusNode.setParantBPlusNode(rightBPlusNode);
                    }
                }
                leftBPlusNode.setBPlusNodes(leftBPlusNodes);
                rightBPlusNode.setBPlusNodes(rightBPlusNodes);
            }

            //当前节点的前节点
            BPlusNode preBPlusNode = BPlusNode.getPreviousBPlusNode();
            //分裂节点后将分裂节点的前节点的后节点设置为左节点
            if (preBPlusNode != null) {
                preBPlusNode.setNextBPlusNode(leftBPlusNode);
            }

            //当前节点的后节点
            BPlusNode nextBPlusNode = BPlusNode.getNextBPlusNode();
            //分裂节点后将分裂节点的后节点的前节点设置为右节点
            if (nextBPlusNode != null) {
                nextBPlusNode.setPreviousBPlusNode(rightBPlusNode);
            }

            //如果由头结点分裂，则分裂后左边的节点为头节点
            if (BPlusNode == head) {
                head = leftBPlusNode;
            }

            //父节点的子节点
            List<BPlusNode> childBPlusNodes = new ArrayList<>();
            childBPlusNodes.add(rightBPlusNode);
            childBPlusNodes.add(leftBPlusNode);
            //分裂
            //当前节点无父节点
            if (BPlusNode.getParantBPlusNode() == null) {
                //父节点的键值对
                List<KeyAndValue> parentKeyAndValues = new ArrayList<>();
                parentKeyAndValues.add(midKeyAndValue);
                //构造父节点
                BPlusNode parentBPlusNode = new BPlusNode(childBPlusNodes, parentKeyAndValues, null, null, null);
                //将子节点与父节点关联
                rightBPlusNode.setParantBPlusNode(parentBPlusNode);
                leftBPlusNode.setParantBPlusNode(parentBPlusNode);
                //当前节点为根节点
                root = parentBPlusNode;
            } else {
                BPlusNode parentBPlusNode = BPlusNode.getParantBPlusNode();
                //将原来的孩子节点（除了被拆分的节点）和新的孩子节点（左孩子和右孩子）合并之后与父节点关联
                childBPlusNodes.addAll(parentBPlusNode.getBPlusNodes());
                //移除正在被拆分的节点
                childBPlusNodes.remove(BPlusNode);
                //将子节点与父节点关联
                parentBPlusNode.setBPlusNodes(childBPlusNodes);
                rightBPlusNode.setParantBPlusNode(parentBPlusNode);
                leftBPlusNode.setParantBPlusNode(parentBPlusNode);
                if (parentBPlusNode.getParantBPlusNode() == null) {
                    root = parentBPlusNode;
                }
                //当前节点有父节点,递归调用拆分的方法,将父节点拆分
                splidBPlusNode(parentBPlusNode, midKeyAndValue);
            }
        } else {
            keyAndValues.add(addkeyAndValue);
            //排序
            Collections.sort(keyAndValues);
        }
    }
```

##### B+树删除操作实现

```
如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤

1.删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。

2.若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。

3.若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。

4.若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步

5.若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步

6.当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。

注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。

下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。
```

**删除后不操作的情况**

![image-20201204231610325](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204231610325.png)

删除22,删除后结果如下图

![image-20201204231627571](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204231627571.png)

**删除借操作**

![image-20201204231627571](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204231627571.png)

删除15

![image-20201204231728529](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204231728529.png)

删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。

![image-20201204231813008](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204231813008.png)

**删除合并操作**

![image-20201204231843984](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204231843984.png)

删除7，删除后的结果如下图所示

![image-20201204231901593](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204231901593.png)

当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。

![image-20201204232002094](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204232002094.png)

此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。

![image-20201204232022330](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201204232022330.png)

删除代码：

```java
public boolean delete(int key) {
        System.out.println("delete:" + key);
        System.out.println();

        //首先找到要删除的key所在的节点
        BPlusNode deleteBPlusNode = (BPlusNode) search(key, root, NODE);
        //如果没找到则删除失败
        if (deleteBPlusNode == null) {
            return false;
        }

        if (deleteBPlusNode == root) {
            delKeyAndValue(root.getKeyAndValue(), key);
            return true;
        }

        if (deleteBPlusNode == head && isNeedMerge(head)) {
            head = head.getNextBPlusNode();
        }

        return merge(deleteBPlusNode, key);
    }
```

合并操作：

```java
//合并节点
    //key 待删除的key
    private boolean mergeBPlusNode(BPlusNode BPlusNode, int key) {
        if (BPlusNode.isRoot()) {
            return false;
        }
        BPlusNode preBPlusNode;
        BPlusNode nextBPlusNode;
        BPlusNode parentBPlusNode = BPlusNode.getParantBPlusNode();
        List<BPlusNode> childBPlusNodes = parentBPlusNode.getBPlusNodes();
        List<BPlusNode> childBPlusNodes1 = BPlusNode.getBPlusNodes();
        List<KeyAndValue> parentKeyAndValue = parentBPlusNode.getKeyAndValue();
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();

        if (BPlusNode.isLeaf()) {
            if (parentKeyAndValue.size() == 1 && parentBPlusNode != root) {
                return true;
            }
            preBPlusNode = getPreviousBPlusNode(BPlusNode);
            nextBPlusNode = getNextBPlusNode(BPlusNode);
            if (preBPlusNode != null) {
                List<KeyAndValue> preKeyAndValues = preBPlusNode.getKeyAndValue();
                keyAndValues.addAll(preKeyAndValues);
                if (preBPlusNode.isHead()) {
                    head = BPlusNode;
                    BPlusNode.setPreviousBPlusNode(null);
                } else {
                    preBPlusNode.getPreviousBPlusNode().setNextBPlusNode(BPlusNode);
                    BPlusNode.setPreviousBPlusNode(preBPlusNode.getPreviousBPlusNode());
                }
                //将合并后节点的后节点设置为当前节点的后节点
                preBPlusNode.setNextBPlusNode(BPlusNode.getNextBPlusNode());
                KeyAndValue keyAndValue = getKeyAndValueinMinAndMax(parentBPlusNode, getMinKeyInBPlusNode(preBPlusNode), key);
                delKeyAndValue(parentKeyAndValue, keyAndValue.getKey());
                if (parentKeyAndValue.isEmpty()) {
                    root = BPlusNode;
                } else {
                    //删除当前节点
                    childBPlusNodes.remove(preBPlusNode);
                }
                Collections.sort(keyAndValues);
                merge(parentBPlusNode, key);
                return true;
            }

            if (nextBPlusNode != null) {
                List<KeyAndValue> nextKeyAndValues = nextBPlusNode.getKeyAndValue();
                keyAndValues.addAll(nextKeyAndValues);
                if (nextBPlusNode.isTail()) {
                    BPlusNode.setPreviousBPlusNode(null);
                } else {
                    nextBPlusNode.getNextBPlusNode().setPreviousBPlusNode(BPlusNode);
                    BPlusNode.setNextBPlusNode(nextBPlusNode.getNextBPlusNode());
                }

                KeyAndValue keyAndValue = getKeyAndValueinMinAndMax(parentBPlusNode, key, getMinKeyInBPlusNode(nextBPlusNode));
                delKeyAndValue(parentKeyAndValue, keyAndValue.getKey());
                if (parentKeyAndValue.isEmpty()) {
                    root = BPlusNode;
                    BPlusNode.setParantBPlusNode(null);
                } else {
                    //删除当前节点
                    childBPlusNodes.remove(nextBPlusNode);
                }
                Collections.sort(keyAndValues);
                merge(parentBPlusNode, key);
                return true;
            }
            //前节点和后节点都等于null那么是root节点
            return false;
        } else {
            preBPlusNode = getPreviousBPlusNode(BPlusNode);
            nextBPlusNode = getNextBPlusNode(BPlusNode);
            if (preBPlusNode != null) {
                //将前一个节点和当前节点还有父节点中的相应Key-value合并
                List<KeyAndValue> preKeyAndValues = preBPlusNode.getKeyAndValue();
                preKeyAndValues.addAll(keyAndValues);
                int min = getMaxKeyInBPlusNode(preBPlusNode);
                int max = getMinKeyInBPlusNode(BPlusNode);
                //父节点中移除这个key-value
                KeyAndValue keyAndValue = getKeyAndValueinMinAndMax(parentBPlusNode, min, max);
                parentKeyAndValue.remove(keyAndValue);
                if (parentKeyAndValue.isEmpty()) {
                    root = preBPlusNode;
                    BPlusNode.setParantBPlusNode(null);
                    preBPlusNode.setParantBPlusNode(null);
                } else {
                    childBPlusNodes.remove(BPlusNode);
                }
                assert nextBPlusNode != null;
                preBPlusNode.setNextBPlusNode(nextBPlusNode.getNextBPlusNode());
                //前节点加上一个当前节点的所有子节点中最小key的key-value
                KeyAndValue minKeyAndValue = getMinKeyAndValueInChildBPlusNode(BPlusNode);
                assert minKeyAndValue != null;
                KeyAndValue keyAndValue1 = new KeyAndValue(minKeyAndValue.getKey(), minKeyAndValue.getValue());
                preKeyAndValues.add(keyAndValue1);
                List<BPlusNode> preChildBPlusNodes = preBPlusNode.getBPlusNodes();
                preChildBPlusNodes.addAll(BPlusNode.getBPlusNodes());
                //将当前节点的孩子节点的父节点设为当前节点的后节点
                for (BPlusNode BPlusNode1 : childBPlusNodes1) {
                    BPlusNode1.setParantBPlusNode(preBPlusNode);
                }
                Collections.sort(preKeyAndValues);
                merge(parentBPlusNode, key);
                return true;
            }

            if (nextBPlusNode != null) {
                //将后一个节点和当前节点还有父节点中的相应Key-value合并
                List<KeyAndValue> nextKeyAndValues = nextBPlusNode.getKeyAndValue();
                nextKeyAndValues.addAll(keyAndValues);

                int min = getMaxKeyInBPlusNode(BPlusNode);
                int max = getMinKeyInBPlusNode(nextBPlusNode);
                //父节点中移除这个key-value
                KeyAndValue keyAndValue = getKeyAndValueinMinAndMax(parentBPlusNode, min, max);
                parentKeyAndValue.remove(keyAndValue);
                childBPlusNodes.remove(BPlusNode);
                if (parentKeyAndValue.isEmpty()) {
                    root = nextBPlusNode;
                    nextBPlusNode.setParantBPlusNode(null);
                } else {
                    childBPlusNodes.remove(BPlusNode);
                }
                nextBPlusNode.setPreviousBPlusNode(BPlusNode.getPreviousBPlusNode());
                //后节点加上一个当后节点的所有子节点中最小key的key-value
                KeyAndValue minKeyAndValue = getMinKeyAndValueInChildBPlusNode(nextBPlusNode);
                assert minKeyAndValue != null;
                KeyAndValue keyAndValue1 = new KeyAndValue(minKeyAndValue.getKey(), minKeyAndValue.getValue());
                nextKeyAndValues.add(keyAndValue1);
                List<BPlusNode> nextChildBPlusNodes = nextBPlusNode.getBPlusNodes();
                nextChildBPlusNodes.addAll(BPlusNode.getBPlusNodes());
                //将当前节点的孩子节点的父节点设为当前节点的后节点
                for (BPlusNode BPlusNode1 : childBPlusNodes1) {
                    BPlusNode1.setParantBPlusNode(nextBPlusNode);
                }
                Collections.sort(nextKeyAndValues);
                merge(parentBPlusNode, key);
                return true;
            }
            return false;
        }
    }
```

全部建树代码如下：

```java
package src.Tree.BPlusTree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @Author : Auraros
 * @Description :
 * @Data : 2020-12-04 22:23
 * @Version : 1.0
 */
public class BPlusTree {

    private static final String  NODE = " NODE";
    static final String INT = "INT";
    private static final String PREBPlusNode = "PREBPlusNode";
    private static final String NEXTBPlusNode = "NEXTBPlusNode";
    //B+树的阶数
    private int rank;
    //根节点
    private BPlusNode root;
    //头结点
    private BPlusNode head;

    BPlusTree(int rank) {
        this.rank = rank;
    }

    public BPlusNode getRoot() {
        return root;
    }

    public void insert(KeyAndValue entry) {
        List<KeyAndValue> keyAndValues1 = new ArrayList<>();
        //插入第一个节点
        if (head == null) {
            keyAndValues1.add(entry);
            head = new BPlusNode(null, keyAndValues1, null, null, null);
            root = new BPlusNode(null, keyAndValues1, null, null, null);
        } else {
            BPlusNode BPlusNode = head;
            //遍历链表，找到插入键值对对应的节点
            while (BPlusNode != null) {
                List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
                int exitFlag = 0;
                //如果插入的键的值和当前节点键值对集合中的某个键的值相等，则直接替换value
                for (KeyAndValue KV : keyAndValues) {
                    if (KV.getKey() == entry.getKey()) {
                        KV.setValue(entry.getValue());
                        exitFlag = 1;
                        break;
                    }
                }
                //如果插入的键已经有了，则退出循环
                if (exitFlag == 1) {
                    break;
                }
                //如果当前节点是最后一个节点或者要插入的键值对的键的值小于下一个节点的键的最小值，则直接插入当前节点
                if (BPlusNode.getNextBPlusNode() == null || BPlusNode.getNextBPlusNode().getKeyAndValue().get(0).getKey() >= entry.getKey()) {
                    splidBPlusNode(BPlusNode, entry);
                    break;
                }
                //移动指针
                BPlusNode = BPlusNode.getNextBPlusNode();
            }
        }
    }


    //判断是否需要拆分节点
    private void splidBPlusNode(BPlusNode BPlusNode, KeyAndValue addkeyAndValue) {
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();

        if (keyAndValues.size() == rank - 1) {
            //先插入待添加的节点
            keyAndValues.add(addkeyAndValue);
            Collections.sort(keyAndValues);
            //取出当前节点的键值对集合
            //取出原来的key-value集合中间位置的下标
            int mid = keyAndValues.size() / 2;
            //取出原来的key-value集合中间位置的键
            int midKey = keyAndValues.get(mid).getKey();
            //构造一个新的键值对，不是叶子节点的节点不存储value的信息
            KeyAndValue midKeyAndValue = new KeyAndValue(midKey, "");
            //将中间位置左边的键值对封装成集合对象
            List<KeyAndValue> leftKeyAndValues = new ArrayList<>();
            for (int i = 0; i < mid; i++) {
                leftKeyAndValues.add(keyAndValues.get(i));
            }
            //将中间位置右边边的键值对封装成集合对象
            List<KeyAndValue> rightKeyAndValues = new ArrayList<>();
            //如果是叶子节点则在原节点中保留上移的key-value，否则原节点删除上移的key-value
            int k;
            if (BPlusNode.isLeaf()) {
                k = mid;
            } else {
                k = mid + 1;
            }
            for (int i = k; i < rank; i++) {
                rightKeyAndValues.add(keyAndValues.get(i));
            }
            //对左右两边的元素重排序
            Collections.sort(leftKeyAndValues);
            Collections.sort(rightKeyAndValues);
            //以mid为界限将当前节点分列成两个节点，维护前指针和后指针
            BPlusNode rightBPlusNode;
            BPlusNode leftBPlusNode;
//            if (BPlusNode.isLeaf()) {
            //如果是叶子节点维护前后指针
            rightBPlusNode = new BPlusNode(null, rightKeyAndValues, BPlusNode.getNextBPlusNode(), null, BPlusNode.getParantBPlusNode());
            leftBPlusNode = new BPlusNode(null, leftKeyAndValues, rightBPlusNode, BPlusNode.getPreviousBPlusNode(), BPlusNode.getParantBPlusNode());
            rightBPlusNode.setPreviousBPlusNode(leftBPlusNode);
//            } else {
//                //如果不是叶子不维护前后指针
//                rightBPlusNode = new BPlusNode(null, rightKeyAndValues, null, null, BPlusNode.getParantBPlusNode());
//                leftBPlusNode = new BPlusNode(null, leftKeyAndValues, null, null, BPlusNode.getParantBPlusNode());
//            }
            //如果当前分裂的节点有孩子节点,设置分裂后节点和孩子节点的关系
            if (BPlusNode.getBPlusNodes() != null) {
                //取得所有地孩子节点
                List<BPlusNode> BPlusNodes = BPlusNode.getBPlusNodes();
                List<BPlusNode> leftBPlusNodes = new ArrayList<>();
                List<BPlusNode> rightBPlusNodes = new ArrayList<>();
                for (BPlusNode childBPlusNode : BPlusNodes) {
                    //取得当前孩子节点的最大键值
                    int max = childBPlusNode.getKeyAndValue().get(childBPlusNode.getKeyAndValue().size() - 1).getKey();
                    if (max < midKeyAndValue.getKey()) {
                        //小于mid处的键的数是左节点的子节点
                        leftBPlusNodes.add(childBPlusNode);
                        childBPlusNode.setParantBPlusNode(leftBPlusNode);
                    } else {
                        //大于mid处的键的数是右节点的子节点
                        rightBPlusNodes.add(childBPlusNode);
                        childBPlusNode.setParantBPlusNode(rightBPlusNode);
                    }
                }
                leftBPlusNode.setBPlusNodes(leftBPlusNodes);
                rightBPlusNode.setBPlusNodes(rightBPlusNodes);
            }

            //当前节点的前节点
            BPlusNode preBPlusNode = BPlusNode.getPreviousBPlusNode();
            //分裂节点后将分裂节点的前节点的后节点设置为左节点
            if (preBPlusNode != null) {
                preBPlusNode.setNextBPlusNode(leftBPlusNode);
            }

            //当前节点的后节点
            BPlusNode nextBPlusNode = BPlusNode.getNextBPlusNode();
            //分裂节点后将分裂节点的后节点的前节点设置为右节点
            if (nextBPlusNode != null) {
                nextBPlusNode.setPreviousBPlusNode(rightBPlusNode);
            }

            //如果由头结点分裂，则分裂后左边的节点为头节点
            if (BPlusNode == head) {
                head = leftBPlusNode;
            }

            //父节点的子节点
            List<BPlusNode> childBPlusNodes = new ArrayList<>();
            childBPlusNodes.add(rightBPlusNode);
            childBPlusNodes.add(leftBPlusNode);
            //分裂
            //当前节点无父节点
            if (BPlusNode.getParantBPlusNode() == null) {
                //父节点的键值对
                List<KeyAndValue> parentKeyAndValues = new ArrayList<>();
                parentKeyAndValues.add(midKeyAndValue);
                //构造父节点
                BPlusNode parentBPlusNode = new BPlusNode(childBPlusNodes, parentKeyAndValues, null, null, null);
                //将子节点与父节点关联
                rightBPlusNode.setParantBPlusNode(parentBPlusNode);
                leftBPlusNode.setParantBPlusNode(parentBPlusNode);
                //当前节点为根节点
                root = parentBPlusNode;
            } else {
                BPlusNode parentBPlusNode = BPlusNode.getParantBPlusNode();
                //将原来的孩子节点（除了被拆分的节点）和新的孩子节点（左孩子和右孩子）合并之后与父节点关联
                childBPlusNodes.addAll(parentBPlusNode.getBPlusNodes());
                //移除正在被拆分的节点
                childBPlusNodes.remove(BPlusNode);
                //将子节点与父节点关联
                parentBPlusNode.setBPlusNodes(childBPlusNodes);
                rightBPlusNode.setParantBPlusNode(parentBPlusNode);
                leftBPlusNode.setParantBPlusNode(parentBPlusNode);
                if (parentBPlusNode.getParantBPlusNode() == null) {
                    root = parentBPlusNode;
                }
                //当前节点有父节点,递归调用拆分的方法,将父节点拆分
                splidBPlusNode(parentBPlusNode, midKeyAndValue);
            }
        } else {
            keyAndValues.add(addkeyAndValue);
            //排序
            Collections.sort(keyAndValues);
        }
    }


    //打印B+树
    void printBPlusTree(BPlusNode root) {
        if (root == this.root) {
            //打印根节点内的元素
            printBPlusNode(root);
            System.out.println();
        }
        if (root == null) {
            return;
        }

        //打印子节点的元素
        if (root.getBPlusNodes() != null) {
            //找到最左边的节点
            BPlusNode leftBPlusNode = null;
            BPlusNode tmpBPlusNode = null;
            List<BPlusNode> childBPlusNodes = root.getBPlusNodes();
            for (BPlusNode BPlusNode : childBPlusNodes) {
                if (BPlusNode.getPreviousBPlusNode() == null) {
                    leftBPlusNode = BPlusNode;
                    tmpBPlusNode = BPlusNode;
                }
            }

            while (leftBPlusNode != null) {
                //从最左边的节点向右打印
                printBPlusNode(leftBPlusNode);
                System.out.print("|");
                leftBPlusNode = leftBPlusNode.getNextBPlusNode();
            }
            System.out.println();
            printBPlusTree(tmpBPlusNode);
        }
    }

    //打印一个节点内的元素
    private void printBPlusNode(BPlusNode BPlusNode) {
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
        for (int i = 0; i < keyAndValues.size(); i++) {
            if (i != (keyAndValues.size() - 1)) {
                System.out.print(keyAndValues.get(i).getKey() + ",");
            } else {
                System.out.print(keyAndValues.get(i).getKey());
            }
        }
    }

    public Object search(int key, BPlusNode BPlusNode, String mode) {

        //如果是叶子节点则直接取值
        if (BPlusNode.isLeaf()) {
            List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
            for (KeyAndValue keyAndValue : keyAndValues) {
                if (keyAndValue.getKey() == key) {
                    switch (mode) {
                        case NODE:
                            return BPlusNode;
                        case INT:
                            return keyAndValue.getValue();
                    }
                }
            }
            return null;
        }


        List<BPlusNode> BPlusNodes = BPlusNode.getBPlusNodes();
        //如果寻找的key小于节点的键的最小值
        int minKey = BPlusNode.getKeyAndValue().get(0).getKey();
        if (key < minKey) {
            for (BPlusNode n : BPlusNodes) {
                List<KeyAndValue> keyAndValues = n.getKeyAndValue();
                //找到子节点集合中最大键小于父节点最小键节点
                if (keyAndValues.get(keyAndValues.size() - 1).getKey() < minKey) {
                    return search(key, n, mode);
                }
            }
        }
        //如果寻找的key大于节点的键的最大值
        int maxKey = getMaxKeyInBPlusNode(BPlusNode);
        if (key >= maxKey) {
            for (BPlusNode n : BPlusNodes) {
                List<KeyAndValue> keyAndValues = n.getKeyAndValue();
                //找到子节点集合中最小键大于等于父节点最小大键节点
                if (keyAndValues.get(0).getKey() >= maxKey) {
                    return search(key, n, mode);
                }
            }
        }

        //如果寻找的key在最大值和最小值之间，首先定位到最窄的区间
        int min = getLeftBoundOfKey(BPlusNode, key);
        int max = getRightBoundOfKey(BPlusNode, key);


        //去所有的子节点中找键的范围在min和max之间的节点
        for (BPlusNode n : BPlusNodes) {
            List<KeyAndValue> kvs = n.getKeyAndValue();
            //找到子节点集合中键的范围在min和max之间的节点
            if (kvs.get(0).getKey() >= min && kvs.get(kvs.size() - 1).getKey() < max) {
                return search(key, n, mode);
            }
        }
        return null;
    }


    public boolean delete(int key) {
        System.out.println("delete:" + key);
        System.out.println();

        //首先找到要删除的key所在的节点
        BPlusNode deleteBPlusNode = (BPlusNode) search(key, root, NODE);
        //如果没找到则删除失败
        if (deleteBPlusNode == null) {
            return false;
        }

        if (deleteBPlusNode == root) {
            delKeyAndValue(root.getKeyAndValue(), key);
            return true;
        }

        if (deleteBPlusNode == head && isNeedMerge(head)) {
            head = head.getNextBPlusNode();
        }

        return merge(deleteBPlusNode, key);
    }


    //平衡当前节点和前节点或者后节点的数量，使两者的数量都满足条件
    private boolean balanceBPlusNode(BPlusNode BPlusNode, BPlusNode bratherBPlusNode, String BPlusNodeType) {
        if (bratherBPlusNode == null) {
            return false;
        }
        List<KeyAndValue> delKeyAndValues = BPlusNode.getKeyAndValue();
        if (isMoreElement(bratherBPlusNode)) {
            List<KeyAndValue> bratherKeyAndValues = bratherBPlusNode.getKeyAndValue();
            int bratherSize = bratherKeyAndValues.size();
            //兄弟节点删除挪走的键值对
            KeyAndValue keyAndValue = null;
            KeyAndValue keyAndValue1;
            switch (BPlusNodeType) {
                case PREBPlusNode:
                    keyAndValue = bratherKeyAndValues.remove(bratherSize - 1);
                    keyAndValue1 = getKeyAndValueinMinAndMax(BPlusNode.getParantBPlusNode(), keyAndValue.getKey(), getMinKeyInBPlusNode(BPlusNode));
                    keyAndValue1.setKey(keyAndValue.getKey());
                    break;
                case NEXTBPlusNode:
                    keyAndValue = bratherKeyAndValues.remove(0);
                    keyAndValue1 = getKeyAndValueinMinAndMax(BPlusNode.getParantBPlusNode(), getMaxKeyInBPlusNode(BPlusNode), keyAndValue.getKey());
                    keyAndValue1.setKey(bratherKeyAndValues.get(0).getKey());
                    break;
            }
            //当前节点添加从前一个节点得来的键值对
            delKeyAndValues.add(keyAndValue);

            //对键值对重排序
            Collections.sort(delKeyAndValues);
            return true;
        }
        return false;
    }

    public boolean merge(BPlusNode BPlusNode, int key) {
        List<KeyAndValue> delKeyAndValues = BPlusNode.getKeyAndValue();
        //首先删除该key-vaule
        delKeyAndValue(delKeyAndValues, key);
        //如果要删除的节点的键值对的数目小于节点最大键值对数目*填充因子
        if (isNeedMerge(BPlusNode)) {
            Boolean isBalance;
            //如果左节点有富余的键值对，则取一个到当前节点
            BPlusNode preBPlusNode = getPreviousBPlusNode(BPlusNode);
            isBalance = balanceBPlusNode(BPlusNode, preBPlusNode, PREBPlusNode);
            //如果此时已经平衡，则已经删除成功
            if (isBalance) return true;

            //如果右兄弟节点有富余的键值对，则取一个到当前节点
            BPlusNode nextBPlusNode = getNextBPlusNode(BPlusNode);
            isBalance = balanceBPlusNode(BPlusNode, nextBPlusNode, NEXTBPlusNode);

            return isBalance || mergeBPlusNode(BPlusNode, key);
        } else {
            return true;
        }
    }

    //合并节点
    //key 待删除的key
    private boolean mergeBPlusNode(BPlusNode BPlusNode, int key) {
        if (BPlusNode.isRoot()) {
            return false;
        }
        BPlusNode preBPlusNode;
        BPlusNode nextBPlusNode;
        BPlusNode parentBPlusNode = BPlusNode.getParantBPlusNode();
        List<BPlusNode> childBPlusNodes = parentBPlusNode.getBPlusNodes();
        List<BPlusNode> childBPlusNodes1 = BPlusNode.getBPlusNodes();
        List<KeyAndValue> parentKeyAndValue = parentBPlusNode.getKeyAndValue();
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();

        if (BPlusNode.isLeaf()) {
            if (parentKeyAndValue.size() == 1 && parentBPlusNode != root) {
                return true;
            }
            preBPlusNode = getPreviousBPlusNode(BPlusNode);
            nextBPlusNode = getNextBPlusNode(BPlusNode);
            if (preBPlusNode != null) {
                List<KeyAndValue> preKeyAndValues = preBPlusNode.getKeyAndValue();
                keyAndValues.addAll(preKeyAndValues);
                if (preBPlusNode.isHead()) {
                    head = BPlusNode;
                    BPlusNode.setPreviousBPlusNode(null);
                } else {
                    preBPlusNode.getPreviousBPlusNode().setNextBPlusNode(BPlusNode);
                    BPlusNode.setPreviousBPlusNode(preBPlusNode.getPreviousBPlusNode());
                }
                //将合并后节点的后节点设置为当前节点的后节点
                preBPlusNode.setNextBPlusNode(BPlusNode.getNextBPlusNode());
                KeyAndValue keyAndValue = getKeyAndValueinMinAndMax(parentBPlusNode, getMinKeyInBPlusNode(preBPlusNode), key);
                delKeyAndValue(parentKeyAndValue, keyAndValue.getKey());
                if (parentKeyAndValue.isEmpty()) {
                    root = BPlusNode;
                } else {
                    //删除当前节点
                    childBPlusNodes.remove(preBPlusNode);
                }
                Collections.sort(keyAndValues);
                merge(parentBPlusNode, key);
                return true;
            }

            if (nextBPlusNode != null) {
                List<KeyAndValue> nextKeyAndValues = nextBPlusNode.getKeyAndValue();
                keyAndValues.addAll(nextKeyAndValues);
                if (nextBPlusNode.isTail()) {
                    BPlusNode.setPreviousBPlusNode(null);
                } else {
                    nextBPlusNode.getNextBPlusNode().setPreviousBPlusNode(BPlusNode);
                    BPlusNode.setNextBPlusNode(nextBPlusNode.getNextBPlusNode());
                }

                KeyAndValue keyAndValue = getKeyAndValueinMinAndMax(parentBPlusNode, key, getMinKeyInBPlusNode(nextBPlusNode));
                delKeyAndValue(parentKeyAndValue, keyAndValue.getKey());
                if (parentKeyAndValue.isEmpty()) {
                    root = BPlusNode;
                    BPlusNode.setParantBPlusNode(null);
                } else {
                    //删除当前节点
                    childBPlusNodes.remove(nextBPlusNode);
                }
                Collections.sort(keyAndValues);
                merge(parentBPlusNode, key);
                return true;
            }
            //前节点和后节点都等于null那么是root节点
            return false;
        } else {
            preBPlusNode = getPreviousBPlusNode(BPlusNode);
            nextBPlusNode = getNextBPlusNode(BPlusNode);
            if (preBPlusNode != null) {
                //将前一个节点和当前节点还有父节点中的相应Key-value合并
                List<KeyAndValue> preKeyAndValues = preBPlusNode.getKeyAndValue();
                preKeyAndValues.addAll(keyAndValues);
                int min = getMaxKeyInBPlusNode(preBPlusNode);
                int max = getMinKeyInBPlusNode(BPlusNode);
                //父节点中移除这个key-value
                KeyAndValue keyAndValue = getKeyAndValueinMinAndMax(parentBPlusNode, min, max);
                parentKeyAndValue.remove(keyAndValue);
                if (parentKeyAndValue.isEmpty()) {
                    root = preBPlusNode;
                    BPlusNode.setParantBPlusNode(null);
                    preBPlusNode.setParantBPlusNode(null);
                } else {
                    childBPlusNodes.remove(BPlusNode);
                }
                assert nextBPlusNode != null;
                preBPlusNode.setNextBPlusNode(nextBPlusNode.getNextBPlusNode());
                //前节点加上一个当前节点的所有子节点中最小key的key-value
                KeyAndValue minKeyAndValue = getMinKeyAndValueInChildBPlusNode(BPlusNode);
                assert minKeyAndValue != null;
                KeyAndValue keyAndValue1 = new KeyAndValue(minKeyAndValue.getKey(), minKeyAndValue.getValue());
                preKeyAndValues.add(keyAndValue1);
                List<BPlusNode> preChildBPlusNodes = preBPlusNode.getBPlusNodes();
                preChildBPlusNodes.addAll(BPlusNode.getBPlusNodes());
                //将当前节点的孩子节点的父节点设为当前节点的后节点
                for (BPlusNode BPlusNode1 : childBPlusNodes1) {
                    BPlusNode1.setParantBPlusNode(preBPlusNode);
                }
                Collections.sort(preKeyAndValues);
                merge(parentBPlusNode, key);
                return true;
            }

            if (nextBPlusNode != null) {
                //将后一个节点和当前节点还有父节点中的相应Key-value合并
                List<KeyAndValue> nextKeyAndValues = nextBPlusNode.getKeyAndValue();
                nextKeyAndValues.addAll(keyAndValues);

                int min = getMaxKeyInBPlusNode(BPlusNode);
                int max = getMinKeyInBPlusNode(nextBPlusNode);
                //父节点中移除这个key-value
                KeyAndValue keyAndValue = getKeyAndValueinMinAndMax(parentBPlusNode, min, max);
                parentKeyAndValue.remove(keyAndValue);
                childBPlusNodes.remove(BPlusNode);
                if (parentKeyAndValue.isEmpty()) {
                    root = nextBPlusNode;
                    nextBPlusNode.setParantBPlusNode(null);
                } else {
                    childBPlusNodes.remove(BPlusNode);
                }
                nextBPlusNode.setPreviousBPlusNode(BPlusNode.getPreviousBPlusNode());
                //后节点加上一个当后节点的所有子节点中最小key的key-value
                KeyAndValue minKeyAndValue = getMinKeyAndValueInChildBPlusNode(nextBPlusNode);
                assert minKeyAndValue != null;
                KeyAndValue keyAndValue1 = new KeyAndValue(minKeyAndValue.getKey(), minKeyAndValue.getValue());
                nextKeyAndValues.add(keyAndValue1);
                List<BPlusNode> nextChildBPlusNodes = nextBPlusNode.getBPlusNodes();
                nextChildBPlusNodes.addAll(BPlusNode.getBPlusNodes());
                //将当前节点的孩子节点的父节点设为当前节点的后节点
                for (BPlusNode BPlusNode1 : childBPlusNodes1) {
                    BPlusNode1.setParantBPlusNode(nextBPlusNode);
                }
                Collections.sort(nextKeyAndValues);
                merge(parentBPlusNode, key);
                return true;
            }
            return false;
        }
    }

    //得到当前节点的前节点
    private BPlusNode getPreviousBPlusNode(BPlusNode BPlusNode) {
        if (BPlusNode.isRoot()) {
            return null;
        }

        BPlusNode parentBPlusNode = BPlusNode.getParantBPlusNode();
        //得到兄弟节点
        List<BPlusNode> BPlusNodes = parentBPlusNode.getBPlusNodes();
        List<KeyAndValue> keyAndValues = new ArrayList<>();
        for (BPlusNode n : BPlusNodes) {
            List<KeyAndValue> list = n.getKeyAndValue();
            int maxKeyAndValue = list.get(list.size() - 1).getKey();
            if (maxKeyAndValue < getMinKeyInBPlusNode(BPlusNode)) {
                keyAndValues.add(new KeyAndValue(maxKeyAndValue, n));
            }
        }
        Collections.sort(keyAndValues);
        if (keyAndValues.isEmpty()) {
            return null;
        }
        return (BPlusNode) keyAndValues.get(keyAndValues.size() - 1).getValue();
    }


    //得到当前节点的后节点
    private BPlusNode getNextBPlusNode(BPlusNode BPlusNode) {
        if (BPlusNode.isRoot()) {
            return null;
        }

        BPlusNode parentBPlusNode = BPlusNode.getParantBPlusNode();
        //得到兄弟节点
        List<BPlusNode> BPlusNodes = parentBPlusNode.getBPlusNodes();
        List<KeyAndValue> keyAndValues = new ArrayList<>();
        for (BPlusNode n : BPlusNodes) {
            List<KeyAndValue> list = n.getKeyAndValue();
            int minKeyAndValue = list.get(0).getKey();
            if (minKeyAndValue > getMaxKeyInBPlusNode(BPlusNode)) {
                keyAndValues.add(new KeyAndValue(minKeyAndValue, n));
            }
        }
        Collections.sort(keyAndValues);
        if (keyAndValues.isEmpty()) {
            return null;
        }
        return (BPlusNode) keyAndValues.get(0).getValue();
    }


    private int getMinKeyInBPlusNode(BPlusNode BPlusNode) {
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
        return keyAndValues.get(0).getKey();
    }

    private int getMaxKeyInBPlusNode(BPlusNode BPlusNode) {
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
        return keyAndValues.get(keyAndValues.size() - 1).getKey();
    }


    private int getLeftBoundOfKey(BPlusNode BPlusNode, int key) {
        int left = 0;
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
        for (int i = 0; i < keyAndValues.size(); i++) {
            if (keyAndValues.get(i).getKey() <= key && keyAndValues.get(i + 1).getKey() > key) {
                left = keyAndValues.get(i).getKey();
                break;
            }
        }
        return left;
    }

    private int getRightBoundOfKey(BPlusNode BPlusNode, int key) {
        int right = 0;
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
        for (int i = 0; i < keyAndValues.size(); i++) {
            if (keyAndValues.get(i).getKey() <= key && keyAndValues.get(i + 1).getKey() > key) {
                right = keyAndValues.get(i + 1).getKey();
                break;
            }
        }
        return right;
    }


    private void delKeyAndValue(List<KeyAndValue> keyAndValues, int key) {
        for (KeyAndValue keyAndValue : keyAndValues) {
            if (keyAndValue.getKey() == key) {
                keyAndValues.remove(keyAndValue);
                break;
            }
        }
    }

    //找到BPlusNode的键值对中在min和max中的键值对
    private KeyAndValue getKeyAndValueinMinAndMax(BPlusNode BPlusNode, int min, int max) {
        if (BPlusNode == null) {
            return null;
        }
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
        KeyAndValue keyAndValue = null;
        for (KeyAndValue k : keyAndValues) {
            if (k.getKey() > min && k.getKey() <= max) {
                keyAndValue = k;
                break;
            }
        }
        return keyAndValue;
    }


    private KeyAndValue getMinKeyAndValueInChildBPlusNode(BPlusNode BPlusNode) {
        if (BPlusNode.getBPlusNodes() == null || BPlusNode.getBPlusNodes().isEmpty()) {
            return null;
        }
        List<KeyAndValue> sortKeyAndValues = new ArrayList<>();
        List<BPlusNode> childBPlusNodes = BPlusNode.getBPlusNodes();
        for (BPlusNode childBPlusNode : childBPlusNodes) {
            List<KeyAndValue> keyAndValues = childBPlusNode.getKeyAndValue();
            KeyAndValue minKeyAndValue = keyAndValues.get(0);
            sortKeyAndValues.add(minKeyAndValue);
        }
        Collections.sort(sortKeyAndValues);
        return sortKeyAndValues.get(0);
    }

    private boolean isNeedMerge(BPlusNode BPlusNode) {
        if (BPlusNode == null) {
            return false;
        }
        List<KeyAndValue> keyAndValues = BPlusNode.getKeyAndValue();
        return keyAndValues.size() < rank / 2;
    }

    //判断一个节点是否有富余的键值对
    private boolean isMoreElement(BPlusNode BPlusNode) {
        return BPlusNode != null && (BPlusNode.getKeyAndValue().size() > rank / 2);
    }

    public static void main(String[] args) { 
        BPlusTree BPlusTree = new BPlusTree(4 );
        KeyAndValue keyAndValue = new KeyAndValue(1,"123");
        KeyAndValue keyAndValue1 = new KeyAndValue(2,"123");
        KeyAndValue keyAndValue2 = new KeyAndValue(3,"123");
        KeyAndValue keyAndValue3 = new KeyAndValue(4,"123");
        KeyAndValue keyAndValue4 = new KeyAndValue(5,"123");
        KeyAndValue keyAndValue5 = new KeyAndValue(6,"123");
        KeyAndValue keyAndValue6 = new KeyAndValue(7,"12300");
        KeyAndValue keyAndValue7 = new KeyAndValue(8,"546");
        KeyAndValue keyAndValue8 = new KeyAndValue(9,"123");
        KeyAndValue keyAndValue9 = new KeyAndValue(10,"123");
        KeyAndValue keyAndValue10 = new KeyAndValue(11,"123");
        KeyAndValue keyAndValue11 = new KeyAndValue(12,"123");
        KeyAndValue keyAndValue12 = new KeyAndValue(13,"123");
        KeyAndValue keyAndValue14 = new KeyAndValue(15,"12345");
        KeyAndValue keyAndValue15 = new KeyAndValue(16,"12345");
        KeyAndValue keyAndValue16 = new KeyAndValue(17,"12345");
        KeyAndValue keyAndValue17 = new KeyAndValue(18,"12345");
        KeyAndValue keyAndValue18 = new KeyAndValue(19,"12345");
        KeyAndValue keyAndValue19 = new KeyAndValue(20,"12345");
        KeyAndValue keyAndValue20 = new KeyAndValue(21,"12345");
        BPlusTree.insert(keyAndValue);
        BPlusTree.insert(keyAndValue5);
        BPlusTree.insert(keyAndValue9);
        BPlusTree.insert(keyAndValue1);
        BPlusTree.insert(keyAndValue7);
        BPlusTree.insert(keyAndValue10);
        BPlusTree.insert(keyAndValue17);
        BPlusTree.insert(keyAndValue2);
        BPlusTree.insert(keyAndValue14);
        BPlusTree.insert(keyAndValue16);
        BPlusTree.insert(keyAndValue11);
        BPlusTree.insert(keyAndValue12);
        BPlusTree.insert(keyAndValue3);
        BPlusTree.insert(keyAndValue8);
        BPlusTree.insert(keyAndValue18);
        BPlusTree.insert(keyAndValue15);
        BPlusTree.insert(keyAndValue4);
        BPlusTree.insert(keyAndValue19);
        BPlusTree.insert(keyAndValue6);
        BPlusTree.insert(keyAndValue20);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(1);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(0);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(2);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(11);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(3);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(4);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(5);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(9);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(6);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(13);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(7);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(10);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(18);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(8);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(12);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(20);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(19);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(15);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        BPlusTree.delete(17);
        BPlusTree.printBPlusTree(BPlusTree.getRoot());
        
    }
}
```


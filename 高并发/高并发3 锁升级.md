# 高并发3 锁升级

```
一开始new的时候是无锁态
第一次上锁就是 偏向锁
有人征用的时候 升级 轻量级锁，自旋锁，无锁
征用状态更激烈 升级 重量级锁
全部记录在markword上面
```

![image-20201231223152881](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201231223152881.png)

布局解释：

```
1. 无锁态：最开始的三位表示 没有锁的状态  0  0  1
		 分代年龄: 新生代GC的 分代标识 JVM(默认值 15)
		 identifity_hashCode:有调用才有值 

2. 偏向锁：最开始的三位表示 偏向锁的状态  1  0  1

3. 升为更重要的锁： 变成了两位标志  00(轻量级锁) 10(重量级锁) 11(GC标记信息)
```

**分代年龄改成31 能实现吗**？

4 个 bit代表分代年龄 最大是 15 不能再大了。

```
当调用 hashCode()函数的时候，会存入哈希值
001 + hashcode
00000001 10101101 00110100 00110110
01011001 00000000 00000000 00000000
```



### 偏向锁

如果一个对象被第一个线程第一次上锁，此时并不会出现真的锁，而是出现一个偏向锁（相当于贴个标签），其中的54位的线程指针指向这个对象。表明这个锁是属于这个线程的，也是这个对象是属于这个线程的，当这个线程再次访问对象的时候就不需要加锁了，直接进行操作。

Epoch 复杂，优化中优化

![image-20201231224147973](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201231224147973.png)



### 轻量级锁

**发生：**有另外一个线程只要发生竞争的时候就会升级为轻量级锁

**怎么产生：**

1. 撤销偏向锁的状态 

   2. 每个线程都有自己的线程栈，在每个线程栈生成一个对象 LockRecord，然后就进行抢占(采用自旋CAS的方式来抢），看栈中的LockRecord的指针谁先抢到锁。

      ![image-20201231225219368](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201231225219368.png)

      ```
      线程A或者B拿到锁的指针，然后进行转换，然后使用CAS操作。看谁先抢成功
      ```

   3. 这个锁的 62 位就会记录那个LockRecord的指针

执行在用户态，不需要跟内核态打交道，效率特别高，



### 重量级锁

**产生：** 因为自旋锁太消耗CPU了，所以就需要进行升级（默认自旋超过10次）

**发生什么：**

竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制
升级重量级锁：-> 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间



**自适应自旋锁**

自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。



### 锁消除 lock eliminate

```java
public void add(String str1,String str2){
         StringBuffer sb = new StringBuffer();
         sb.append(str1).append(str2);
}
```

我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。



### 锁粗化 lock coarsening

```java
public String test(String str){
       
       int i = 0;
       StringBuffer sb = new StringBuffer():
       while(i < 100){
           sb.append(str);
           i++;
       }
       return sb.toString():
}
```

JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。